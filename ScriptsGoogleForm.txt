/**
 * T·ªáp Apps Script n√†y th·ª±c hi·ªán c√°c nhi·ªám v·ª• t·ª± ƒë·ªông cho Google Form.
 * PHI√äN B·∫¢N 24.8 (ƒê·ªìng b·ªô L·ªãch d·ªçn d·∫πp)
 *
 * - (M·ªöI V24.8) ƒê·ªìng b·ªô l·ªãch d·ªçn d·∫πp. "Kh√°c" (OTH) s·∫Ω d·ªçn d·∫πp c√πng "ƒê·∫°i s·ªë" (THU) l√∫c 18:00 T5 v√† c√πng "H√¨nh h·ªçc" (SUN) l√∫c 17:00 CN.
 * - (V24.7) Gi·ªØ nguy√™n h·∫°n n·ªôp Kh√°c (OTH_A) l√† 23:00 Th·ª© 3.
 * - (V24.5) Gi·ªØ nguy√™n h·∫°n n·ªôp ƒê·∫°i s·ªë (THU) l√† 23:00 Th·ª© 3.
 */

// ==================================================================
// PH·∫¶N C·∫§U H√åNH (B·∫ÆT BU·ªòC)
// ==================================================================

// 1. (*** Gi·ªØ nguy√™n V10 ***) C·∫•u h√¨nh Google Drive (D√πng ID)
const PARENT_FOLDER_THU_ID = "1IySQLWKcMaIQZ6XmOvDJf9OeDTmQYiRD";
const PARENT_FOLDER_SUN_ID = "1-kmfNyUA-iSANbFRSaW5TUiT8kciDd-a";
const PARENT_FOLDER_OTH_ID = "1F_h6sa-I6wmf-3KVrJ49Kg6KJZyJM-Vu";

// 2. (*** Gi·ªØ nguy√™n V10 ***) C·∫•u h√¨nh C√¢u h·ªèi Form
const STUDENT_NAME_QUESTION_TITLE = "T√™n h·ªçc sinh (ch·ªâ ƒëi·ªÅn t√™n ƒë·ªám v√† t√™n):";
const ASSIGNMENT_TYPE_QUESTION_TITLE = "Ch·ªçn b√†i t·∫≠p:";
const ASSIGNMENT_TYPE_THU = "B√†i t·∫≠p th·ª© 5 (ƒê·∫°i s·ªë)";
const ASSIGNMENT_TYPE_SUN = "B√†i t·∫≠p Ch·ªß nh·∫≠t (H√¨nh h·ªçc)";
const ASSIGNMENT_TYPE_OTH = "Kh√°c";


// 3. (*** C·∫¨P NH·∫¨T V14.3 ***) C·∫•u h√¨nh 3 Sheet (D√πng ID trang t√≠nh - GID)
const SHEET_ID = "1GiQWCCgl9XAJ6DqTiSjRZkzPztaT6nEix3qyZmCOHV8"; // ID C·ªßa FILE

// (*** M·ªöI V14 ***) C·∫≠p nh·∫≠t GID (ID trang t√≠nh)
const SHEET_TAB_ID_THU = "1234172792"; // <<< GID (ID TRANG T√çNH) C·ª¶A SHEET ƒê·∫†I S·ªê
const SHEET_TAB_ID_SUN = "566805598"; // <<< GID (ID TRANG T√çNH) C·ª¶A SHEET H√åNH H·ªåC
const SHEET_TAB_ID_OTH = "125828814"; // <<< GID (ID TRANG T√çNH) C·ª¶A SHEET KH√ÅC

// C·∫•u h√¨nh cho Sheet (Trang) B√ÄI T·∫¨P TH·ª® 5
const SHEET_NAME_THU = "B·∫£ng nh·∫≠n x√©t (ƒê·∫°i s·ªë)";
const NAME_COLUMN_THU = "B";
const CHECKBOX_COLUMN_THU = "G";

// C·∫•u h√¨nh cho Sheet (Trang) B√ÄI T·∫¨P CH·ª¶ NH·∫¨T
const SHEET_NAME_SUN = "B·∫£ng nh·∫≠n x√©t (H√¨nh h·ªçc)";
const NAME_COLUMN_SUN = "B";
const CHECKBOX_COLUMN_SUN = "G";

// C·∫•u h√¨nh cho Sheet (Trang) B√ÄI T·∫¨P KH√ÅC
const SHEET_NAME_OTH = "B·∫£ng nh·∫≠n x√©t (Kh√°c)";
const NAME_COLUMN_OTH = "B";
const CHECKBOX_COLUMN_OTH = "G";


// 4. (*** Gi·ªØ nguy√™n V10 ***) C·∫•u h√¨nh Email th√¥ng b√°o
const RECIPIENT_EMAIL = "trungdzid3@gmail.com";
const SUBJECT_TEMPLATE_THU = "Bi·ªÉu m·∫´u: B√†i t·∫≠p Th·ª© 5";
const SUBJECT_TEMPLATE_SUN = "Bi·ªÉu m·∫´u: B√†i t·∫≠p Ch·ªß Nh·∫≠t";
const SUBJECT_TEMPLATE_OTH = "Bi·ªÉu m·∫´u: B√†i t·∫≠p Kh√°c";

// 5. (*** C·∫¨P NH·∫¨T V24.7 ***) C·∫•u h√¨nh l·ªãch n·ªôp b√†i
const TIME_OPEN_THU_NUM = (5 * 10000) + (0 * 100) + 0; // 50000 (Th·ª© 6 00:00)
const TIME_CLOSE_THU_NUM = (2 * 10000) + (23 * 100) + 0; // 22300 (Th·ª© 3 23:00) (V24.5)

const TIME_OPEN_SUN_NUM = (1 * 10000) + (12 * 100) + 0; // 11200 (Th·ª© 2 12:00)
const TIME_CLOSE_SUN_NUM = (6 * 10000) + (22 * 100) + 0; // 62200 (Th·ª© 7 22:00)

const TIME_OPEN_OTH_NUM_A = (1 * 10000) + (12 * 100) + 0; // 11200 (Th·ª© 2 12:00)
const TIME_CLOSE_OTH_NUM_A = (2 * 10000) + (23 * 100) + 0; // 22300 (Th·ª© 3 23:00) (V24.7)

const TIME_OPEN_OTH_NUM_B = (5 * 10000) + (0 * 100) + 0; // 50000 (Th·ª© 6 00:00)
const TIME_CLOSE_OTH_NUM_B = (6 * 10000) + (22 * 100) + 0; // 62200 (Th·ª© 7 22:00)

// 6. (M·ªöI V14.1) C·∫•u h√¨nh Du di
const GRACE_PERIOD_MINUTES = 10; // <<< S·ªê PH√öT DU DI (10 PH√öT)

// 7. (C·∫¨P NH·∫¨T V14.3) C·∫•u h√¨nh L·ªùi khen n·ªôp s·ªõm
const EARLY_SUBMISSION_COMMENT = "L√†m b√†i t·∫≠p v·ªÅ nh√† chƒÉm ch·ªâ, tinh th·∫ßn h·ªçc t·∫≠p t·ªët, l√†m v√† n·ªôp BTVN t·ª´ s·ªõm.";

// 7.1 (C·∫¨P NH·∫¨T V14.3+) T·ª™ KH√ìA ƒê·ªÇ T√åM C·ªòT ∆ØU ƒêI·ªÇM (ƒê√£ m·ªü r·ªông)
const ADVANTAGE_KEYWORDS = [
  "∆∞u ƒëi·ªÉm", "∆∞u", "t·ªët", "gi·ªèi", "khen", "nh·∫≠n x√©t", // T·ª´ kh√≥a g·ªëc
  "t√≠ch c·ª±c", "ph√™", "th∆∞·ªüng", "c·ªông" // T·ª´ kh√≥a m·ªõi (ƒë√£ b·ªè "ƒë√°nh gi√°", "l·ªùi ph√™")
];

// 7.2 (M·ªöI V20) C·∫•u h√¨nh ng∆∞·ª°ng Typo
const TYPO_THRESHOLD = 2; // CH·ªà cho ph√©p sai 1 ho·∫∑c 2 k√Ω t·ª±

// 7.3 (M·ªöI V21) Ti·ªÅn t·ªë (Prefix) c·∫ßn lo·∫°i b·ªè khi chu·∫©n h√≥a
const PREFIX_KEYWORDS_TO_REMOVE = ["con", "em", "b·∫°n", "ch√°u", "hs", "hoc sinh"];


// ==================================================================
// K·∫æT TH√öC C·∫§U H√åNH
// ==================================================================


/**
 * H√ÄM WEB APP V14 (Gi·ªØ nguy√™n)
 * (*** C·∫¨P NH·∫¨T V20: Th√™m x√≥a cache khi s·ª≠a l·ªói ***)
 */
function doGet(e) {
  Logger.log("ƒê√£ nh·∫≠n ƒë∆∞·ª£c y√™u c·∫ßu Web App (doGet)");
  let message = "ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.";
  
  try {
    const params = e.parameter;
    const action = params.action;
    const sheetTabId = params.sheetTabId; 
    const formName = params.formName;
    
    if (!sheetTabId) {
        message = "L·ªñI: Y√™u c·∫ßu thi·∫øu sheetTabId.";
        Logger.log(message);
        return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
    }

    const lock = LockService.getScriptLock();
    lock.waitLock(10000); 
      
    try {
      let spreadSheet;
      try {
        spreadSheet = SpreadsheetApp.openById(SHEET_ID);
      } catch (openErr) {
        Logger.log(`L·ªñI NGHI√äM TR·ªåNG (doGet): Kh√¥ng th·ªÉ m·ªü Sheet ID. L·ªói: ${openErr.message}`);
        message = `L·ªñI: Kh√¥ng th·ªÉ m·ªü Google Sheet. D·ªãch v·ª• Google c√≥ th·ªÉ ƒëang t·∫°m th·ªùi gi√°n ƒëo·∫°n.`;
        lock.releaseLock();
        return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
      }
      
      const sheet = getSheetByTabId(spreadSheet, sheetTabId); 
      
      if (!sheet) {
          message = `L·ªñI: Kh√¥ng t√¨m th·∫•y trang t√≠nh v·ªõi GID "${sheetTabId}".`;
          Logger.log(message);
          lock.releaseLock();
          return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
      }
      const sheetName = sheet.getName(); 

      // --- Logic M·ªöI V13: S·ª≠a l·ªói (action=correct) ---
      if (action === "correct") {
        const oldRow = params.oldRow;
        const oldCol = params.oldCol;
        const newRow = params.newRow;
        const newCol = params.newCol;
        
        if (oldRow && oldCol && newRow && newCol) {
          const oldCell = sheet.getRange(`${oldCol}${oldRow}`);
          oldCell.setValue(false); 
          
          const newCell = sheet.getRange(`${newCol}${newRow}`);
          newCell.setValue(true); 
          
          // (*** C·∫¨P NH·∫¨T V20 ***)
          // N·∫øu ƒë√¢y l√† h√†nh ƒë·ªông s·ª≠a l·ªói, ch√∫ng ta c·∫ßn x√≥a c·ªù "ƒë√£ g·ª≠i mail"
          // ƒë·ªÉ n·∫øu reconcile ch·∫°y l·∫°i, n√≥ c√≥ th·ªÉ g·ª≠i mail ti·∫øp n·∫øu c·∫ßn.
          const scriptProperties = PropertiesService.getScriptProperties();
          const cacheKeyOld = `reconcile_email_${sheetTabId}_${oldRow}`;
          const cacheKeyNew = `reconcile_email_${sheetTabId}_${newRow}`;
          scriptProperties.deleteProperty(cacheKeyOld);
          scriptProperties.deleteProperty(cacheKeyNew);

          message = `X√ÅC NH·∫¨N S·ª¨A L·ªñI: ƒê√£ B·ªé ƒë√°nh d·∫•u √¥ ${oldCol}${oldRow} v√† ƒê√ÅNH D·∫§U √¥ ${newCol}${newRow} cho "${formName}" (Sheet: ${sheetName}). ƒê√£ x√≥a c·ªù cache.`;
          Logger.log(message);
        } else {
          message = "L·ªñI (S·ª≠a l·ªói): Thi·∫øu tham s·ªë (oldRow, oldCol, newRow, newCol).";
          Logger.log(message);
        }

      // --- Logic C≈© V12: ƒê√°nh d·∫•u (action=mark) ---
      } else if (action === "mark") {
        // (H√†m n√†y hi·ªán kh√¥ng d√πng, nh∆∞ng gi·ªØ l·∫°i ƒë·ªÉ d·ª± ph√≤ng)
        const row = params.row;
        const col = params.col;

        if (row && col) {
          const cell = sheet.getRange(`${col}${row}`);
          if (cell.getValue() !== true) {
            cell.setValue(true);
            message = `X√ÅC NH·∫¨N: ƒê√£ ƒë√°nh d·∫•u checkbox cho "${formName}" t·∫°i √¥ ${col}${row} (Sheet: ${sheetName}).`;
            Logger.log(message);
          } else {
            message = `TH√îNG B√ÅO: Checkbox t·∫°i √¥ ${col}${row} (Sheet: ${sheetName}) ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u t·ª´ tr∆∞·ªõc.`;
          }
        } else {
          message = "L·ªñI (ƒê√°nh d·∫•u): Thi·∫øu tham s·ªë (row, col).";
          Logger.log(message);
        }
      } else {
        message = "L·ªñI: H√†nh ƒë·ªông kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Ch·ªâ h·ªó tr·ª£ 'action=mark' ho·∫∑c 'action=correct'.";
        Logger.log(message);
      }

    } catch (err) {
      message = `L·ªói khi c·∫≠p nh·∫≠t Sheet: ${err.message}`;
      Logger.log(message);
    } finally {
      lock.releaseLock();
    }
  } catch (err)
 {
    message = `L·ªói nghi√™m tr·ªçng trong doGet: ${err.message}`;
    Logger.log(message);
  }
  
  // Tr·∫£ v·ªÅ trang HTML th√¥ng b√°o cho ng∆∞·ªùi d√πng
  return HtmlService.createHtmlOutput(
    `<html>
      <head>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .container { padding: 20px; border: 1px solid #ccc; border-radius: 8px; background-color: #f9f9f9; }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Th√¥ng b√°o t·ª´ H·ªá th·ªëng T·ª± ƒë·ªông</h2>
          <p>${message}</p>
          <p>B·∫°n c√≥ th·ªÉ ƒë√≥ng tab n√†y.</p>
        </div>
      </body>
    </html>`
  );
}


/**
 * H√ÄM 1: Ch·∫°y t·ª± ƒë·ªông khi c√≥ ng∆∞·ªùi n·ªôp bi·ªÉu m·∫´u.
 * (Gi·ªØ nguy√™n V23)
 */
function onFormSubmit(e) {
  try {
    // === Ph·∫ßn 1: L·∫•y th√¥ng tin c∆° b·∫£n ===
    const form = FormApp.getActiveForm();
    const formResponse = e.response;
    const now = new Date(); // Th·ªùi gian n·ªôp B√ÄI G·ªêC
    
    // (*** V14.1 : LOGIC DU DI ***)
    const adjustedTime = new Date(now.getTime() - GRACE_PERIOD_MINUTES * 60000);
    const day = adjustedTime.getDay();
    const hour = adjustedTime.getHours();
    const minute = adjustedTime.getMinutes();
    const currentTimeNum = (day * 10000) + (hour * 100) + minute; // D√πng ƒë·ªÉ t√≠nh "isOverdue"

    // (*** M·ªöI V14.2: D√πng th·ªùi gian G·ªêC ƒë·ªÉ t√≠nh "isEarly" ***)
    const realDay = now.getDay();
    const realHour = now.getHours();
    const realMinute = now.getMinutes();
    const realTimeNum = (realDay * 10000) + (realHour * 100) + realMinute;

    // L·∫•y t√™n h·ªçc sinh
    const studentName = getResponseByTitle(formResponse, STUDENT_NAME_QUESTION_TITLE);
    if (!studentName) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y c√¢u tr·∫£ l·ªùi cho c√¢u h·ªèi: "${STUDENT_NAME_QUESTION_TITLE}". ƒêang tho√°t.`);
      return;
    }
    
    // L·∫•y lo·∫°i b√†i t·∫≠p
    let assignmentType = getResponseByTitle(formResponse, ASSIGNMENT_TYPE_QUESTION_TITLE);
    if (!assignmentType) {
        Logger.log(`Kh√¥ng t√¨m th·∫•y c√¢u tr·∫£ l·ªùi cho c√¢u h·ªèi: "${ASSIGNMENT_TYPE_QUESTION_TITLE}". S·∫Ω x·ª≠ l√Ω nh∆∞ b√†i t·∫≠p Kh√°c (m·∫∑c ƒë·ªãnh) v√† Qu√° h·∫°n.`);
    }

    // === Ph·∫ßn 2: X√°c ƒë·ªãnh th∆∞ m·ª•c ƒë√≠ch, tr·∫°ng th√°i, v√† n·ªôp s·ªõm ===
    let targetParentFolder;
    let isOverdue = false;
    let emailSubjectBase;
    let isEarly = false; // (*** M·ªöI V14.2 ***)

    if (assignmentType === ASSIGNMENT_TYPE_THU) {
        targetParentFolder = DriveApp.getFolderById(PARENT_FOLDER_THU_ID);
        emailSubjectBase = SUBJECT_TEMPLATE_THU;
        // T√≠nh Qu√° h·∫°n (d√πng th·ªùi gian ƒë√£ du di)
        if (currentTimeNum < TIME_OPEN_THU_NUM && currentTimeNum >= TIME_CLOSE_THU_NUM) {
            isOverdue = true;
        }
        // (*** M·ªöI V14.2 ***) T√≠nh N·ªôp s·ªõm (d√πng th·ªùi gian G·ªêC)
        isEarly = checkIsEarly(now, TIME_CLOSE_THU_NUM, 2);
        
    } else if (assignmentType === ASSIGNMENT_TYPE_SUN) {
        targetParentFolder = DriveApp.getFolderById(PARENT_FOLDER_SUN_ID);
        emailSubjectBase = SUBJECT_TEMPLATE_SUN;
        // T√≠nh Qu√° h·∫°n
        if (currentTimeNum < TIME_OPEN_SUN_NUM || currentTimeNum >= TIME_CLOSE_SUN_NUM) {
            isOverdue = true;
        }
        // (*** M·ªöI V14.2 ***) T√≠nh N·ªôp s·ªõm
        isEarly = checkIsEarly(now, TIME_CLOSE_SUN_NUM, 2);

    } else { // (Bao g·ªìm Kh√°c v√† M·∫∑c ƒë·ªãnh)
        targetParentFolder = DriveApp.getFolderById(PARENT_FOLDER_OTH_ID);
        emailSubjectBase = SUBJECT_TEMPLATE_OTH;
        
        let deadlineNum; // (*** M·ªöI V14.2 ***)
        
        if (assignmentType === ASSIGNMENT_TYPE_OTH) { // N·∫øu l√† "Kh√°c"
            // (*** C·∫¨P NH·∫¨T V24.7: D√πng m·ªëc TIME_CLOSE_OTH_NUM_A m·ªõi ***)
            const isOnTime_A = (currentTimeNum >= TIME_OPEN_OTH_NUM_A && currentTimeNum < TIME_CLOSE_OTH_NUM_A);
            const isOnTime_B = (currentTimeNum >= TIME_OPEN_OTH_NUM_B && currentTimeNum < TIME_CLOSE_OTH_NUM_B);
            if (!(isOnTime_A || isOnTime_B)) {
                isOverdue = true;
            }
            // (*** M·ªöI V14.2 ***) T√¨m h·∫°n ch√≥t g·∫ßn nh·∫•t cho L·ªõp Kh√°c
            deadlineNum = (realTimeNum < TIME_OPEN_OTH_NUM_B) ? TIME_CLOSE_OTH_NUM_A : TIME_CLOSE_OTH_NUM_B;
            isEarly = checkIsEarly(now, deadlineNum, 1); // Y√™u c·∫ßu 1 ng√†y

        } else { // N·∫øu l√† lo·∫°i b√†i t·∫≠p kh√¥ng x√°c ƒë·ªãnh
            isOverdue = true;
            Logger.log(`Lo·∫°i b√†i t·∫≠p kh√¥ng h·ª£p l·ªá ("${assignmentType}"). ƒê√£ chuy·ªÉn v√†o th∆∞ m·ª•c "${targetParentFolder.getName()}" v√† ƒë√°nh d·∫•u Qu√° h·∫°n.`);
            assignmentType = ASSIGNMENT_TYPE_OTH; // √âp v·ªÅ "Kh√°c" ƒë·ªÉ ƒë√°nh d·∫•u
            // (*** M·ªöI V14.2 ***) T√≠nh h·∫°n ch√≥t cho tr∆∞·ªùng h·ª£p m·∫∑c ƒë·ªãnh
            deadlineNum = (realTimeNum < TIME_OPEN_OTH_NUM_B) ? TIME_CLOSE_OTH_NUM_A : TIME_CLOSE_OTH_NUM_B;
            isEarly = checkIsEarly(now, deadlineNum, 1);
        }
    }

    // === Ph·∫ßn 3: X·ª≠ l√Ω file tr√™n Drive (*** C·∫¨P NH·∫¨T V24.4 ***) ===
    
    // (V24.4) ƒê·ªïi ƒë·ªãnh d·∫°ng t√™n th∆∞ m·ª•c
    const studentFolderName = isOverdue ? `[Qu√° h·∫°n] ${studentName}` : studentName;
    let studentFolder = findExistingStudentFolder(targetParentFolder, studentName);
    
    if (!studentFolder) {
        Logger.log(`Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c th√¥ng minh cho "${studentName}". ƒêang t·∫°o m·ªõi: "${studentFolderName}"`);
        studentFolder = targetParentFolder.createFolder(studentFolderName);
    } else {
        Logger.log(`T√¨m th·∫•y th∆∞ m·ª•c th√¥ng minh: "${studentFolder.getName()}". S·∫Ω g·ªôp t·ªáp v√†o ƒë√¢y.`);
        if (isOverdue && !studentFolder.getName().toLowerCase().includes("qu√° h·∫°n")) {
            try {
                // (V24.4) ƒê·ªïi ƒë·ªãnh d·∫°ng t√™n th∆∞ m·ª•c
                const newOverdueName = `[Qu√° h·∫°n] ${studentFolder.getName()}`;
                studentFolder.setName(newOverdueName);
                Logger.log(`ƒê√£ ƒë·ªïi t√™n th∆∞ m·ª•c th√†nh: "${newOverdueName}"`);
            } catch (renameErr) {
                Logger.log(`L·ªói khi ƒë·ªïi t√™n th∆∞ m·ª•c th√†nh qu√° h·∫°n: ${renameErr.message}`);
            }
        }
    }

    // (X·ª≠ l√Ω t·ªáp gi·ªØ nguy√™n V13... kh√¥ng thay ƒë·ªïi)
    const fileResponses = formResponse.getItemResponses().filter(item => item.getItem().getType() === FormApp.ItemType.FILE_UPLOAD);
    if (fileResponses.length > 0) {
      fileResponses.forEach(fileResponse => {
        const files = fileResponse.getResponse();
        files.forEach(fileId => {
          try {
            const file = DriveApp.getFileById(fileId);
            const mimeType = file.getMimeType();
            const fileName = file.getName();
            if (mimeType === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" || mimeType === "application/msword") {
              convertFileToPdf(file, studentFolder);
            } else {
              const existingFiles = studentFolder.getFilesByName(fileName);
              if (existingFiles.hasNext()) {
                Logger.log(`T·ªáp "${fileName}" ƒë√£ t·ªìn t·∫°i. B·ªè qua t·ªáp m·ªõi.`);
                file.setTrashed(true);
              } else {
                file.moveTo(studentFolder);
                Logger.log(`ƒê√£ di chuy·ªÉn (th√™m m·ªõi) t·ªáp "${fileName}" v√†o th∆∞ m·ª•c "${studentFolder.getName()}".`);
              }
            }
          } catch (fileErr) {
            Logger.log(`L·ªói khi x·ª≠ l√Ω t·ªáp ID ${fileId} (onFormSubmit): ${fileErr.message}`);
          }
        });
      });
    }

    // === Ph·∫ßn 4: (*** C·∫¨P NH·∫¨T V24 ***) C·∫≠p nh·∫≠t Google Sheet (Logic 4 Giai ƒëo·∫°n) ===
    
    // G·ªçi H√†m 2 (V24) v√† truy·ªÅn tr·∫°ng th√°i "isEarly"
    findAndMarkCheckbox(studentName, assignmentType, "onFormSubmit", isEarly);


    // === Ph·∫ßn 5: G·ª≠i Email th√¥ng b√°o (Gi·ªØ nguy√™n V14.1) ===
    if (RECIPIENT_EMAIL && RECIPIENT_EMAIL !== "your_email@example.com") {
      try {
        const overdueStatus = isOverdue ? " [QU√Å H·∫†N]" : "";
        const subject = `${emailSubjectBase} t·ª´: ${studentName}${overdueStatus}`; 
        const body = `B·∫°n v·ª´a nh·∫≠n ƒë∆∞·ª£c b√†i n·ªôp m·ªõi t·ª´ h·ªçc sinh:\n\n`
                      + `T√™n: ${studentName}\n`
                      + `Lo·∫°i b√†i: ${assignmentType || 'Kh√¥ng x√°c ƒë·ªãnh'}\n`
                      + `Tr·∫°ng th√°i: ${isOverdue ? 'QU√Å H·∫†N' : 'ƒê√∫ng h·∫°n'}\n\n`
                      + `Th·ªùi gian n·ªôp: ${now.toLocaleString('vi-VN')}\n`
                      + `T·ªáp ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o th∆∞ m·ª•c: "${studentFolder.getName()}" (trong "${targetParentFolder.getName()}")`;

        MailApp.sendEmail(RECIPIENT_EMAIL, subject, body);
        Logger.log(`ƒê√£ g·ª≠i email th√¥ng b√°o t·ªõi ${RECIPIENT_EMAIL} cho ${studentName}.`);

      } catch (mailErr) {
        Logger.log(`L·ªói khi g·ª≠i email: ${mailErr.message}`);
      }
    } else {
      Logger.log("Ch∆∞a c·∫•u h√¨nh RECIPIENT_EMAIL. B·ªè qua b∆∞·ªõc g·ª≠i mail.");
    }

  } catch (err) {
    Logger.log(`L·ªói nghi√™m tr·ªçng trong onFormSubmit: ${err.message}`);
  }
}

// ------------------------------------------------------------------
// PH·∫¶N C·∫¶N THAY TH·∫æ (V24.1)
// ------------------------------------------------------------------

/**
 * H√ÄM (H·ªñ TR·ª¢ - C·∫¨P NH·∫¨T V24.1): X√≥a S·∫†CH (File + Folder) trong th∆∞ m·ª•c cha.
 *
 * @param {GoogleAppsScript.Drive.Folder} parentFolder Th∆∞ m·ª•c cha c·∫ßn d·ªçn d·∫πp.
 */
function clearFolderContents(parentFolder) {
  if (!parentFolder) {
    Logger.log(`L·ªói (clearFolderContents): Th∆∞ m·ª•c cha kh√¥ng t·ªìn t·∫°i ho·∫∑c ID sai.`);
    return;
  }
  
  const folderName = parentFolder.getName();
  Logger.log(`ƒêang d·ªçn d·∫πp TO√ÄN B·ªò n·ªôi dung trong: "${folderName}"...`);
  
  try {
    // 1. X√≥a t·∫•t c·∫£ c√°c T·ªÜP TIN (Files) n·∫±m tr·ª±c ti·∫øp trong th∆∞ m·ª•c cha
    const files = parentFolder.getFiles();
    let fileCount = 0;
    while (files.hasNext()) {
      const file = files.next();
      file.setTrashed(true);
      fileCount++;
    }

    // 2. X√≥a t·∫•t c·∫£ c√°c TH∆Ø M·ª§C CON (Folders)
    const subfolders = parentFolder.getFolders();
    let folderCount = 0;
    while (subfolders.hasNext()) {
      const folder = subfolders.next();
      folder.setTrashed(true);
      folderCount++;
    }
    
    Logger.log(`ƒê√£ d·ªçn d·∫πp xong "${folderName}": X√≥a ${fileCount} t·ªáp v√† ${folderCount} th∆∞ m·ª•c con.`);
    
  } catch (err) {
    Logger.log(`L·ªói khi d·ªçn d·∫πp th∆∞ m·ª•c "${folderName}": ${err.message}`);
  }
}


/**
 * D·ªåN D·∫∏P: X√≥a to√†n b·ªô n·ªôi dung trong folder b√†i t·∫≠p v√† x√≥a email th√¥ng b√°o li√™n quan
 * G·ªçi th·ªß c√¥ng ho·∫∑c t·ª´ menu: cleanAssignmentAndEmailsByFolderId(folderId, assignmentType)
 *
 * @param {string} folderId - ID c·ªßa th∆∞ m·ª•c b√†i t·∫≠p (assignment folder)
 * @param {string=} assignmentType - T√™n lo·∫°i b√†i t·∫≠p (d√πng ƒë·ªÉ ch·ªçn m·∫´u ti√™u ƒë·ªÅ email)
 */
function cleanAssignmentAndEmailsByFolderId(folderId, assignmentType) {
  try {
    if (!folderId) {
      Logger.log('cleanAssignmentAndEmailsByFolderId: Thi·∫øu folderId.');
      return;
    }

    // 1) D·ªçn n·ªôi dung folder
    var parentFolder = DriveApp.getFolderById(folderId);
    if (!parentFolder) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y folder v·ªõi ID: ${folderId}`);
      return;
    }

    Logger.log(`üîÑ B·∫Øt ƒë·∫ßu d·ªçn folder b√†i t·∫≠p: ${parentFolder.getName()} (${folderId})`);
    clearFolderContents(parentFolder);

    // 2) X√≥a email li√™n quan (n·∫øu c√≥ m·∫´u ti√™u ƒë·ªÅ)
    var at = (assignmentType || '').toString().toLowerCase();
    var subjectTemplate = SUBJECT_TEMPLATE_OTH; // m·∫∑c ƒë·ªãnh

    if (at.indexOf('thu') !== -1 || at.indexOf('th·ª©') !== -1) {
      subjectTemplate = SUBJECT_TEMPLATE_THU;
    } else if (at.indexOf('cn') !== -1 || at.indexOf('ch·ªß') !== -1) {
      subjectTemplate = SUBJECT_TEMPLATE_SUN;
    }

    Logger.log(`‚Üí D·ªçn email v·ªõi m·∫´u ti√™u ƒë·ªÅ: ${subjectTemplate}`);
    cleanupOldEmails(subjectTemplate);

    Logger.log(`‚úÖ Ho√†n t·∫•t d·ªçn d·∫πp folder & email cho: ${parentFolder.getName()}`);
    return `OK: cleaned ${parentFolder.getName()}`;
  } catch (e) {
    Logger.log(`‚ùå L·ªói cleanAssignmentAndEmailsByFolderId: ${e.message}`);
    return `ERROR: ${e.message}`;
  }
}


/**
 * H√ÄM 2: (*** C·∫¨P NH·∫¨T V24 - LOGIC "KH·ªöP 2 T·ª™ CU·ªêI" ***)
 * (Gi·ªØ nguy√™n V24)
 */
function findAndMarkCheckbox(originalName, assignmentType, context, isEarly) {
  if (!originalName) return null;

  try {
    // === 1. CH·ªåN SHEET C·∫§U H√åNH (Gi·ªØ nguy√™n V14.3) ===
    let sheetNameConfig, sheetTabIdConfig, nameColumnLetter, checkboxColumnLetter;
    let expectedType; 

    if (assignmentType === ASSIGNMENT_TYPE_THU) {
        sheetNameConfig = SHEET_NAME_THU;
        sheetTabIdConfig = SHEET_TAB_ID_THU; 
        nameColumnLetter = NAME_COLUMN_THU; 
        checkboxColumnLetter = CHECKBOX_COLUMN_THU;
        expectedType = "THU";
    } else if (assignmentType === ASSIGNMENT_TYPE_SUN) {
        sheetNameConfig = SHEET_NAME_SUN;
        sheetTabIdConfig = SHEET_TAB_ID_SUN; 
        nameColumnLetter = NAME_COLUMN_SUN; 
        checkboxColumnLetter = CHECKBOX_COLUMN_SUN;
        expectedType = "SUN";
    } else {
        sheetNameConfig = SHEET_NAME_OTH;
        sheetTabIdConfig = SHEET_TAB_ID_OTH; 
        nameColumnLetter = NAME_COLUMN_OTH; 
        checkboxColumnLetter = CHECKBOX_COLUMN_OTH;
        expectedType = "OTH";
    }

    if (SHEET_ID === "YOUR_SINGLE_SHEET_ID_HERE") {
        Logger.log(`Ch∆∞a c·∫•u h√¨nh SHEET_ID. B·ªè qua ƒë√°nh d·∫•u.`);
        return null;
    }

    let spreadSheet;
    try {
      spreadSheet = SpreadsheetApp.openById(SHEET_ID);
    } catch (openErr) {
      Logger.log(`L·ªñI NGHI√äM TR·ªåNG (findAndMarkCheckbox): Kh√¥ng th·ªÉ m·ªü Sheet ID. L·ªói: ${openErr.message}. T√™n n·ªôp: ${originalName}`);
      return null; 
    }
    
    const sheet = getSheetByTabId(spreadSheet, sheetTabIdConfig); 
    
    if (!sheet) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y Sheet Name "${sheetNameConfig}" (ho·∫∑c GID "${sheetTabIdConfig}").`);
      return null;
    }

    // (Gi·ªØ nguy√™n V14.3) T·ª± ƒë·ªông t√¨m C·ªôt ∆Øu ƒëi·ªÉm
    let advantageColumnLetter = null;
    if (isEarly && context === 'onFormSubmit') { 
      advantageColumnLetter = findAndCacheAdvantageColumn(sheet, sheetTabIdConfig);
    }

    // === 2. T·∫†O MAP D·ªÆ LI·ªÜU T·ª™ SHEET (*** C·∫¨P NH·∫¨T V24 ***) ===
    const nameColumnValues = sheet.getRange(`${nameColumnLetter}1:${nameColumnLetter}${sheet.getLastRow()}`).getValues();
    const checkboxValues = sheet.getRange(`${checkboxColumnLetter}1:${checkboxColumnLetter}${sheet.getLastRow()}`).getValues();
    
    const mapList = [];
    for (let i = 0; i < nameColumnValues.length; i++) {
        const nameInSheet = nameColumnValues[i][0];
        if (nameInSheet && typeof nameInSheet === 'string') {
            const isChecked = checkboxValues[i][0] === true;
            
            // (V24) Chu·∫©n h√≥a 1 l·∫ßn
            const originalLC = nameInSheet.toLowerCase().trim();
            const normalizedName = normalizeString(nameInSheet); 
            const words = originalLC.split(/\s+/).filter(Boolean);
            const normalizedWords = normalizedName.split(/\s+/).filter(Boolean);

            // (*** M·ªöI V24: L·∫•y 2 t·ª´ cu·ªëi ***)
            const lastTwoWords = words.slice(-2).join(' '); // vd: "minh to√†n" (c√≥ d·∫•u)
            const normalizedLastTwoWords = normalizedWords.slice(-2).join(' '); // vd: "minh toan" (ko d·∫•u)

            mapList.push({
                original: nameInSheet,
                originalLC: originalLC, // (V23)
                normalized: normalizedName, // (V23)
                
                // (*** M·ªöI V24 ***)
                lastTwoWords: lastTwoWords,
                normalizedLastTwoWords: normalizedLastTwoWords,
                
                row: i + 1,
                isChecked: isChecked,
                location: { 
                  type: expectedType,
                  row: i + 1,
                  isChecked: isChecked,
                  sheetTabId: sheetTabIdConfig,
                  sheetName: sheetNameConfig,
                  checkboxCol: checkboxColumnLetter
                }
            });
        }
    }
    
    const targetMapList = mapList; 
      
    if (targetMapList.length === 0) {
      Logger.log(`(H√†m 2) Kh√¥ng t√¨m th·∫•y t√™n n√†o trong Sheet ${sheetNameConfig}.`);
      return null; 
    }

    // === 3. CHU·∫®N B·ªä T√äN T·ª™ FORM/DRIVE (*** C·∫¨P NH·∫¨T V24 ***) ===
    // (V24) Ch√∫ng ta c·∫ßn t√™n ƒë·∫ßy ƒë·ªß (chu·ªói), kh√¥ng ph·∫£i m·∫£ng t·ª´
    const nameFromForm = originalName.toLowerCase().trim();
    const normalizedNameFromForm = normalizeString(originalName); 
    
    let bestMatch = null;
    let matchLevel = null;

    // === 4. CH·∫†Y LOGIC GIAI ƒêO·∫†N (*** C·∫¨P NH·∫¨T V24 ***) ===

    // -- GIAI ƒêO·∫†N 1: Kh·ªõp tuy·ªát ƒë·ªëi (c√≥ d·∫•u) --
    bestMatch = targetMapList.find(item => item.originalLC === nameFromForm);
    if (bestMatch) matchLevel = "Phase 1 - Exact";

    // -- GIAI ƒêO·∫†N 2: (M·ªöI V24) Kh·ªõp 2 T·ª´ Cu·ªëi (c√≥ d·∫•u) --
    // (Ki·ªÉm tra xem T√™n Form/Drive C√ì CH·ª®A 2 t·ª´ cu·ªëi c·ªßa T√™n Sheet kh√¥ng)
    if (!bestMatch) {
      bestMatch = targetMapList.find(item => 
          item.lastTwoWords.length > 5 && // (Ng∆∞·ª°ng an to√†n: "Minh To√†n" > 5)
          nameFromForm.includes(item.lastTwoWords)
      );
      if (bestMatch) matchLevel = "Phase 2 - LastTwo (Accent)";
    }

    // -- GIAI ƒêO·∫†N 3: (M·ªöI V24) Kh·ªõp 2 T·ª´ Cu·ªëi (KH√îNG d·∫•u) --
    if (!bestMatch) {
      bestMatch = targetMapList.find(item => 
          item.normalizedLastTwoWords.length >= 5 && // (Ng∆∞·ª°ng an to√†n)
          normalizedNameFromForm.includes(item.normalizedLastTwoWords)
      );
      if (bestMatch) matchLevel = "Phase 3 - LastTwo (Normalized)";
    }
    
    // --- N·∫æU GIAI ƒêO·∫†N 1-3 TH√ÄNH C√îNG: ƒê√°nh d·∫•u v√† Tho√°t ---
    if (bestMatch) {
      const cellAddress = `${checkboxColumnLetter}${bestMatch.row}`;
      
      if (bestMatch.isChecked !== true) {
         sheet.getRange(cellAddress).setValue(true); // ƒê√°nh d·∫•u TRUE
      }
      Logger.log(`(H√†m 2) ƒê√£ ƒë√°nh d·∫•u ${cellAddress} cho "${originalName}" (Kh·ªõp "${bestMatch.original}" - C·∫•p ƒë·ªô: ${matchLevel}).`);
      
      if (advantageColumnLetter) { 
        addEarlyComment(sheet, advantageColumnLetter, bestMatch.row);
      }
      return { match: bestMatch, level: matchLevel }; 
    }

    // -- GIAI ƒêO·∫†N 4: SUY ƒêO√ÅN TYPO (Levenshtein) --
    // (Gi·ªØ nguy√™n logic V23: so s√°nh t√™n ƒë·∫ßy ƒë·ªß)
    let typoTargetMapList = targetMapList;
    if (context === 'onFormSubmit') {
       typoTargetMapList = targetMapList.filter(item => !item.isChecked);
    }
    
    let typoCandidates = [];

    for (const item of typoTargetMapList) {
      const distance = levenshteinDistance(normalizedNameFromForm, item.normalized);
      if (distance <= TYPO_THRESHOLD && distance > 0) {
        typoCandidates.push({
            ...item,
            distance: distance
        });
      }
    }
    
    typoCandidates.sort((a, b) => a.distance - b.distance);

    // === 5. K·∫æT QU·∫¢ V√Ä G·ª¨I EMAIL "ƒêO√ÅN V√Ä S·ª¨A" (Gi·ªØ nguy√™n V23) ===
    if (typoCandidates.length > 0) {
      const bestGuess = typoCandidates[0];
      const otherCandidates = typoCandidates.slice(1); 
      
      const cellAddress = `${checkboxColumnLetter}${bestGuess.row}`;
      
      if (bestGuess.isChecked !== true) {
         sheet.getRange(cellAddress).setValue(true); // ƒê√°nh d·∫•u TRUE
      }
      Logger.log(`(H√†m 2) Gƒê 4: T·ª∞ ƒê·ªòNG ƒêO√ÅN. ƒê√£ ƒë√°nh d·∫•u ${cellAddress} cho "${originalName}" (Kh·ªõp "${bestGuess.original}").`);

      if (advantageColumnLetter) { 
        addEarlyComment(sheet, advantageColumnLetter, bestGuess.row);
      }

      if (context.startsWith('onFormSubmit') || context.startsWith('reconcile')) {
         const scriptProperties = PropertiesService.getScriptProperties();
         const cacheKey = `reconcile_email_${sheetTabIdConfig}_${bestGuess.row}`;
         const alreadyEmailed = scriptProperties.getProperty(cacheKey);

         if (!alreadyEmailed) {
            sendCorrectionEmail(originalName, sheetNameConfig, sheetTabIdConfig, checkboxColumnLetter, bestGuess, otherCandidates);
            scriptProperties.setProperty(cacheKey, 'true', 21600 * 20); // 6 ng√†y
         } else {
            Logger.log(`(H√†m 2) ƒê√£ t√¨m th·∫•y kh·ªõp Typo, nh∆∞ng ƒë√£ g·ª≠i email cho √¥ ${cacheKey} tr∆∞·ªõc ƒë√≥. B·ªè qua g·ª≠i mail.`);
         }
      }
      
      return { match: bestGuess, level: "Phase 4 - Typo" }; 
    
    } else {
      Logger.log(`(H√†m 2) Kh√¥ng t√¨m th·∫•y h√†ng n√†o kh·ªõp (k·ªÉ c·∫£ Typo) v·ªõi t√™n "${originalName}" (Sheet ${sheetNameConfig}).`);
      return null; 
    }

  } catch (err) {
    Logger.log(`L·ªói nghi√™m tr·ªçng trong findAndMarkCheckbox: ${err.message}`);
    return null; 
  }
}


/**
 * H√ÄM 3: (*** C·∫¨P NH·∫¨T V24.8 - ƒê·ªíNG B·ªò L·ªäCH D·ªåN D·∫∏P ***)
 * Ch·∫°y d·ªçn d·∫πp theo l·ªãch (T5 18:00, CN 17:00) v√† ƒë·∫£m b·∫£o Form m·ªü.
 * Y√äU C·∫¶U TRIGGER CH·∫†Y H√ÄNG GI·ªú (HOURLY).
 */
function runScheduledCleanupAndEnsureOpen() {
  try {
    const form = FormApp.getActiveForm();
    
    // 1. ƒê·∫£m b·∫£o Form lu√¥n m·ªü
    if (!form.isAcceptingResponses()) {
      form.setAcceptingResponses(true);
      Logger.log("Bi·ªÉu m·∫´u ƒëang ƒê√ìNG. ƒê√£ M·ªû L·∫†I.");
    }

    const now = new Date();
    const day = now.getDay(); // 0:CN, 1:T2, 4:T5, 5:T6, 6:T7
    const hour = now.getHours();
    const minute = now.getMinutes(); 
    const scriptProperties = PropertiesService.getScriptProperties();
    
    const todayKey = now.toLocaleDateString("vi-VN"); 

    // --- 1. L·ªäCH TH·ª® 5 (ƒê·∫†I S·ªê + KH√ÅC): 18h00 Th·ª© 5 (C·∫≠p nh·∫≠t V24.8) ---
    // (H·∫°n n·ªôp T3 23:00. D·ªçn d·∫πp T5 18:00 tr∆∞·ªõc gi·ªù h·ªçc)
    if (day === 4 && hour >= 18) {
      const lastRunThu = scriptProperties.getProperty('LAST_CLEANUP_THU');
      const lastRunOth = scriptProperties.getProperty('LAST_CLEANUP_OTH');
      
      // D·ªçn d·∫πp ƒê·∫†I S·ªê
      if (lastRunThu !== todayKey) {
        Logger.log(">>> ƒê·∫æN GI·ªú D·ªåN D·∫∏P: TH·ª® 5 (ƒê·∫†I S·ªê) <<<");
        const parentFolderThu = DriveApp.getFolderById(PARENT_FOLDER_THU_ID);
        cleanupOldEmails(SUBJECT_TEMPLATE_THU);
        cleanupOldFormResponses(form, ASSIGNMENT_TYPE_THU);
        clearFolderContents(parentFolderThu);
        scriptProperties.setProperty('LAST_CLEANUP_THU', todayKey);
        clearReconcileEmailCache(scriptProperties); // X√≥a cache 1 l·∫ßn l√† ƒë·ªß
        Logger.log("--- Ho√†n t·∫•t d·ªçn d·∫πp TH·ª® 5 ---");
      }
      
      // (V24.8) D·ªçn d·∫πp KH√ÅC (Ch·∫°y c√πng l√∫c T5)
      if (lastRunOth !== todayKey) {
        Logger.log(">>> ƒê·∫æN GI·ªú D·ªåN D·∫∏P: KH√ÅC (ƒê·ª£t T5) <<<");
        const parentFolderOth = DriveApp.getFolderById(PARENT_FOLDER_OTH_ID);
        cleanupOldEmails(SUBJECT_TEMPLATE_OTH);
        cleanupOldFormResponses(form, ASSIGNMENT_TYPE_OTH);
        clearFolderContents(parentFolderOth);
        scriptProperties.setProperty('LAST_CLEANUP_OTH', todayKey);
        // Kh√¥ng c·∫ßn x√≥a cache email l·∫ßn n·ªØa
        Logger.log("--- Ho√†n t·∫•t d·ªçn d·∫πp KH√ÅC (ƒê·ª£t T5) ---");
      }
    }

    // --- 2. L·ªäCH CH·ª¶ NH·∫¨T (H√åNH H·ªåC + KH√ÅC): 17h00 Ch·ªß Nh·∫≠t (C·∫≠p nh·∫≠t V24.8) ---
    else if (day === 0 && hour >= 17) {
      const lastRunSun = scriptProperties.getProperty('LAST_CLEANUP_SUN');
      const lastRunOth = scriptProperties.getProperty('LAST_CLEANUP_OTH');
      
      // D·ªçn d·∫πp H√åNH H·ªåC
      if (lastRunSun !== todayKey) {
        Logger.log(">>> ƒê·∫æN GI·ªú D·ªåN D·∫∏P: CH·ª¶ NH·∫¨T (H√åNH H·ªåC) <<<");
        const parentFolderSun = DriveApp.getFolderById(PARENT_FOLDER_SUN_ID);
        cleanupOldEmails(SUBJECT_TEMPLATE_SUN);
        cleanupOldFormResponses(form, ASSIGNMENT_TYPE_SUN);
        clearFolderContents(parentFolderSun);
        scriptProperties.setProperty('LAST_CLEANUP_SUN', todayKey);
        clearReconcileEmailCache(scriptProperties); // X√≥a cache 1 l·∫ßn
        Logger.log("--- Ho√†n t·∫•t d·ªçn d·∫πp CH·ª¶ NH·∫¨T ---");
      }
      
      // (V24.8) D·ªçn d·∫πp KH√ÅC (Ch·∫°y c√πng l√∫c CN)
      // (Ki·ªÉm tra todayKey kh√°c v·ªõi l·∫ßn ch·∫°y T5)
      const lastRunOthDate = scriptProperties.getProperty('LAST_CLEANUP_OTH');
      if (lastRunOthDate !== todayKey) {
         Logger.log(">>> ƒê·∫æN GI·ªú D·ªåN D·∫∏P: KH√ÅC (ƒê·ª£t CN) <<<");
        const parentFolderOth = DriveApp.getFolderById(PARENT_FOLDER_OTH_ID);
        cleanupOldEmails(SUBJECT_TEMPLATE_OTH);
        cleanupOldFormResponses(form, ASSIGNMENT_TYPE_OTH);
        clearFolderContents(parentFolderOth);
        scriptProperties.setProperty('LAST_CLEANUP_OTH', todayKey);
        Logger.log("--- Ho√†n t·∫•t d·ªçn d·∫πp KH√ÅC (ƒê·ª£t CN) ---");
      }
    }
    
    // --- 3. L·ªäCH KH√ÅC (Th·ª© 2) ---
    // (*** ƒê√É X√ìA B·ªé TRONG V24.8 ***)

  } catch (err) {
    Logger.log(`L·ªñI NGHI√äM TR·ªåNG trong runScheduledCleanupAndEnsureOpen: ${err.message}`);
  }
}


/**
 * H√ÄM (H·ªñ TR·ª¢): D·ªçn d·∫πp email c≈©.
 * (Gi·ªØ nguy√™n V13/V24)
 */
function cleanupOldEmails(subjectTemplate) {
  try {
    if (!subjectTemplate) {
        Logger.log("cleanupOldEmails: Kh√¥ng c√≥ m·∫´u ti√™u ƒë·ªÅ (subjectTemplate), kh√¥ng th·ªÉ x√≥a email.");
        return;
    }
    const searchQuery = `subject:"${subjectTemplate}" in:inbox is:read`; 
    const threads = GmailApp.search(searchQuery);
    if (threads.length > 0) {
      GmailApp.moveThreadsToTrash(threads);
      Logger.log(`ƒê√£ x√≥a ${threads.length} email th√¥ng b√°o c≈©.`);
    } else {
      Logger.log("Kh√¥ng t√¨m th·∫•y email th√¥ng b√°o c≈© n√†o.");
    }
  } catch (gmailErr) {
    Logger.log(`L·ªói khi d·ªçn d·∫πp email c≈©: ${gmailErr.message}`);
  }
}

/**
 * H√ÄM (H·ªñ TR·ª¢): D·ªçn d·∫πp c√¢u tr·∫£ l·ªùi form c≈©.
 * (Gi·ªØ nguy√™n V13/V24)
 */
function cleanupOldFormResponses(form, assignmentTypeToDelete) {
    Logger.log(`B·∫Øt ƒë·∫ßu x√≥a c√¢u tr·∫£ l·ªùi Form cho: "${assignmentTypeToDelete}"`);
    let deleteCount = 0;
    try {
      const responses = form.getResponses();
      let assignmentQuestionItemId = null;
      const items = form.getItems();
      for (let i = 0; i < items.length; i++) {
        if (items[i].getTitle() === ASSIGNMENT_TYPE_QUESTION_TITLE) {
          assignmentQuestionItemId = items[i].getId();
          break;
        }
      }

      if (assignmentQuestionItemId === null) {
        Logger.log(`Kh√¥ng t√¨m th·∫•y ID c√¢u h·ªèi cho: "${ASSIGNMENT_TYPE_QUESTION_TITLE}". Kh√¥ng th·ªÉ x√≥a c√¢u tr·∫£ l·ªùi.`);
        return;
      }

      for (let i = 0; i < responses.length; i++) {
        const response = responses[i];
        let itemResponse;
        try {
           itemResponse = response.getResponseForItem(form.getItemById(assignmentQuestionItemId));
        } catch (e) {
           continue; 
        }

        if (itemResponse && itemResponse.getResponse() === assignmentTypeToDelete) {
          form.deleteResponse(response.getId());
          deleteCount++;
        }
      }
      Logger.log(`ƒê√É X√ìA ${deleteCount} c√¢u tr·∫£ l·ªùi kh·ªõp v·ªõi "${assignmentTypeToDelete}".`);
    } catch (err) {
      Logger.log(`L·ªói khi x√≥a c√¢u tr·∫£ l·ªùi c√≥ ch·ªçn l·ªçc: ${err.message}`);
    }
}

// ------------------------------------------------------------------
// K·∫æT TH√öC PH·∫¶N THAY TH·∫æ
// ------------------------------------------------------------------


/**
 * H√ÄM 4: D·ªåN D·∫∏P ƒê·ªäNH K·ª≤ (DOCX)
 * (Gi·ªØ nguy√™n V13)
 */
function periodicCleanup() {
  Logger.log("--- B·∫Øt ƒë·∫ßu Qu√©t D·ªçn & Chuy·ªÉn ƒê·ªïi ƒê·ªãnh K·ª≥ (DOCX) ---");
  
  const parentFolderThu = DriveApp.getFolderById(PARENT_FOLDER_THU_ID); 
  const parentFolderSun = DriveApp.getFolderById(PARENT_FOLDER_SUN_ID); 
  const parentFolderOth = DriveApp.getFolderById(PARENT_FOLDER_OTH_ID); 

  let totalConverted = 0;
  totalConverted += scanAndConvertFolder(parentFolderThu);
  totalConverted += scanAndConvertFolder(parentFolderSun);
  totalConverted += scanAndConvertFolder(parentFolderOth); 

  Logger.log(`--- Ho√†n t·∫•t Qu√©t D·ªçn ƒê·ªãnh K·ª≥. T·ªïng c·ªông ƒë√£ chuy·ªÉn ƒë·ªïi ${totalConverted} t·ªáp s√≥t l·∫°i. ---`);
}

/**
 * H√ÄM (H·ªñ TR·ª¢): Qu√©t m·ªôt th∆∞ m·ª•c cha, t√¨m th∆∞ m·ª•c con v√† chuy·ªÉn ƒë·ªïi t·ªáp docx.
 * (Gi·ªØ nguy√™n V23)
 */
function scanAndConvertFolder(parentFolder) {
  if (!parentFolder) {
    Logger.log(`Kh√¥ng t√¨m th·∫•y m·ªôt th∆∞ m·ª•c cha, b·ªè qua qu√©t DOCX.`);
    return 0;
  }

  Logger.log(`ƒêang qu√©t d·ªçn DOCX trong: "${parentFolder.getName()}"`);
  let filesConverted = 0;
  try {
    const subfolders = parentFolder.getFolders();

    while (subfolders.hasNext()) {
      const studentFolder = subfolders.next();
      if (studentFolder.getName().startsWith("[") && studentFolder.getName().endsWith("]")) {
        Logger.log(`B·ªè qua th∆∞ m·ª•c l∆∞u tr·ªØ: ${studentFolder.getName()}`);
        continue;
      }

      const docxFiles = studentFolder.getFilesByType("application/vnd.openxmlformats-officedocument.wordprocessingml.document");
      while (docxFiles.hasNext()) {
        const file = docxFiles.next();
        convertFileToPdf(file, studentFolder); 
        filesConverted++;
      }

      const docFiles = studentFolder.getFilesByType("application/msword");
      while (docFiles.hasNext()) {
        const file = docFiles.next();
        convertFileToPdf(file, studentFolder); 
        filesConverted++;
      }
    }
    Logger.log(`Ho√†n t·∫•t qu√©t "${parentFolder.getName()}", ƒë√£ chuy·ªÉn ƒë·ªïi ${filesConverted} t·ªáp.`);
  } catch (err) {
    Logger.log(`L·ªói khi qu√©t d·ªçn DOCX trong "${parentFolder.getName()}": ${err.message}`);
  }
  return filesConverted;
}


// ==================================================================
// C√ÅC H√ÄM H·ªñ TR·ª¢ (Ti·ªán √≠ch)
// ==================================================================

/**
 * (*** C·∫¨P NH·∫¨T V24.3 ***) Chuy·ªÉn ƒë·ªïi DOCX sang PDF (X·ª≠ l√Ω l·ªói h·ªèng t·ªáp)
 * N·∫øu chuy·ªÉn ƒë·ªïi l·ªói, s·∫Ω ƒë·ªïi t√™n t·ªáp g·ªëc ƒë·ªÉ ƒë√°nh d·∫•u.
 */
function convertFileToPdf(file, targetFolder) {
  const fileName = file.getName(); // L·∫•y t√™n t·ªáp ngay t·ª´ ƒë·∫ßu
  try {
    if (file.isTrashed()) return;
    
    const pdfName = fileName.replace(/\.docx?$/i, '.pdf');

    const existingPdfs = targetFolder.getFilesByName(pdfName);
    if (existingPdfs.hasNext()) {
        Logger.log(`T·ªáp PDF "${pdfName}" ƒë√£ t·ªìn t·∫°i. B·ªè qua chuy·ªÉn ƒë·ªïi.`);
        file.setTrashed(true);
        return; 
    }

    Logger.log(`Ph√°t hi·ªán t·ªáp DOCX/DOC (ID: ${file.getId()}): "${fileName}"`);
    
    let pdfBlob;
    try {
      // T√°ch ri√™ng kh·ªëi chuy·ªÉn ƒë·ªïi ƒë·ªÉ b·∫Øt l·ªói c·ª• th·ªÉ
      pdfBlob = file.getAs('application/pdf');
      
    } catch (conversionErr) {
      // --- L·ªñI C·ª§ TH·ªÇ KHI CONVERSION FAILED ---
      Logger.log(`--- L·ªñI CHUY·ªÇN ƒê·ªîI PDF ---`);
      Logger.log(`L·ªói khi chuy·ªÉn ƒë·ªïi t·ªáp "${fileName}": ${conversionErr.message}`);
      Logger.log(`T·ªáp n√†y c√≥ th·ªÉ b·ªã h·ªèng, tr·ªëng ho·∫∑c kh√¥ng h·ª£p l·ªá. S·∫Ω ƒë·ªïi t√™n t·ªáp g·ªëc.`);
      
      try {
        // ƒê·ªïi t√™n t·ªáp g·ªëc ƒë·ªÉ kh√¥ng ch·∫°y l·∫°i v√† ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt
        file.setName(`[L·ªñI CHUY·ªÇN ƒê·ªîI] ${fileName}`);
      } catch (renameErr) {
        Logger.log(`Kh√¥ng th·ªÉ ƒë·ªïi t√™n t·ªáp l·ªói: ${renameErr.message}`);
      }
      return; // D·ª´ng, kh√¥ng l√†m g√¨ n·ªØa v·ªõi t·ªáp n√†y
    }

    // --- N·∫øu chuy·ªÉn ƒë·ªïi th√†nh c√¥ng ---
    const pdfFile = targetFolder.createFile(pdfBlob).setName(pdfName);
    Logger.log(`ƒê√£ CHUY·ªÇN ƒê·ªîI "${fileName}" th√†nh "${pdfFile.getName()}" v√† l∆∞u v√†o "${targetFolder.getName()}".`);
    file.setTrashed(true); // X√≥a t·ªáp g·ªëc

  } catch (generalErr) {
    // L·ªói chung (v√≠ d·ª•: kh√¥ng l·∫•y ƒë∆∞·ª£c t√™n, kh√¥ng c√≥ quy·ªÅn, v.v.)
    Logger.log(`L·ªói chung (ngo√†i conversion) v·ªõi t·ªáp "${fileName}": ${generalErr.message}`);
  }
}


/**
 * (Gi·ªØ nguy√™n V13) L·∫•y c√¢u tr·∫£ l·ªùi t·ª´ m·ªôt FormResponse b·∫±ng Ti√™u ƒë·ªÅ c√¢u h·ªèi.
 */
function getResponseByTitle(formResponse, title) {
  const itemResponses = formResponse.getItemResponses();
  for (let i = 0; i < itemResponses.length; i++) {
    if (itemResponses[i].getItem().getTitle() === title) {
      return itemResponses[i].getResponse();
    }
  }
  return null;
}

/**
 * (Gi·ªØ nguy√™n V13) L·∫•y m·ªôt th∆∞ m·ª•c. N·∫øu ch∆∞a c√≥, t·∫°o m·ªõi.
 */
function getOrCreateFolder(root, folderName) {
  const folders = root.getFoldersByName(folderName);
  if (folders.hasNext()) {
    return folders.next();
  } else {
    return root.createFolder(folderName);
  }
}

/**
 * (Giƒü·ªØ nguy√™n V13) L·∫•y m·ªôt th∆∞ m·ª•c ch·ªâ b·∫±ng t√™n (kh√¥ng t·∫°o m·ªõi).
 */
function getFolderByName(root, folderName) {
  const folders = root.getFoldersByName(folderName);
  if (folders.hasNext()) {
    return folders.next();
  }
  return null;
}

/**
 * (Gi·ªØ nguy√™n V23: D√πng logic "Smart Match" (A.every || B.every))
 * T√¨m ki·∫øm th√¥ng minh m·ªôt th∆∞ m·ª•c con d·ª±a tr√™n t√™n h·ªçc sinh.
 */
function findExistingStudentFolder(parentFolder, studentName) {
  try {
    const studentNameNormalized = normalizeString(studentName);
    const studentNameWords = studentNameNormalized.split(/\s+/).filter(Boolean);
    const allSubfolders = parentFolder.getFolders();
    let foundFolders = [];

    while (allSubfolders.hasNext()) {
      const folder = allSubfolders.next();
      const folderName = folder.getName();
      
      const folderNameNormalized = normalizeString(folderName);
      const folderNameWords = folderNameNormalized.split(/\s+/).filter(Boolean);

      if (folderNameWords.length === 0 || studentNameWords.length === 0) continue;

      const studentWordsInFolder = studentNameWords.every(word => folderNameWords.includes(word));
      const folderWordsInStudent = folderNameWords.every(word => studentNameWords.includes(word));

      if (studentWordsInFolder || folderWordsInStudent) {
        foundFolders.push(folder);
      }
    }

    if (foundFolders.length === 1) {
      return foundFolders[0];
    } else if (foundFolders.length > 1) {
       Logger.log(`T√¨m th·∫•y ${foundFolders.length} th∆∞ m·ª•c kh·ªõp v·ªõi "${studentName}". S·∫Ω t·∫°o th∆∞ m·ª•c m·ªõi ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n.`);
       return null;
    } else {
       return null;
    }

  } catch (err) {
       Logger.log(`L·ªói khi t√¨m ki·∫øm th∆∞ m·ª•c th√¥ng minh: ${err.message}`);
       return null;
  }
}


/**
 * (Gi·ªØ nguy√™n V13)
 */
function openForm() {
  const form = FormApp.getActiveForm();
  form.setAcceptingResponses(true);
  Logger.log("ƒê√£ M·ªû bi·ªÉu m·∫´u (ch·∫°y th·ªß c√¥ng).");
}
/**
 * (Gi·ªØ nguy√™n V13)
 */
function closeForm() {
  const form = FormApp.getActiveForm();
  form.setAcceptingResponses(false);
  Logger.log("ƒê√£ ƒê√ìNG bi·ªÉu m·∫´u (ch·∫°y th·ªß c√¥ng).");
}

// ==================================================================
// H√ÄM 5: (*** C·∫¨P NH·∫¨T V24 - G·ªåI H√ÄM 2 (V24) ***) 
// (Gi·ªØ nguy√™n logic V21/V23 - Ch·ªâ g·ªçi H√†m 2)
// ==================================================================

/**
 * H√ÄM (H·ªñ TR·ª¢ V21): Qu√©t Drive ƒë·ªÉ x√¢y d·ª±ng "B·∫£n ƒë·ªì Ngu·ªìn S·ª± Th·∫≠t".
 * (Gi·ªØ nguy√™n V23)
 */
function buildDriveStudentMap_V21() {
  Logger.log("(V21) B·∫Øt ƒë·∫ßu qu√©t 3 th∆∞ m·ª•c Drive ƒë·ªÉ x√¢y d·ª±ng b·∫£n ƒë·ªì (List)...");
  const driveList = []; 
  const driveMap = {}; 

  // H√†m con ƒë·ªÉ qu√©t m·ªôt th∆∞ m·ª•c cha
  const scanParentFolder = (folderId, assignmentType) => {
    try {
      const parentFolder = DriveApp.getFolderById(folderId);
      const subfolders = parentFolder.getFolders();
      
      while (subfolders.hasNext()) {
        const folder = subfolders.next();
        const originalName = folder.getName();
        
        if (originalName.startsWith("[") && originalName.endsWith("]")) {
           Logger.log(`(V21) B·ªè qua th∆∞ m·ª•c l∆∞u tr·ªØ: ${originalName}`);
           continue;
        }

        const normalizedName = normalizeString(originalName); 
        
        if (normalizedName) {
          if (!driveMap[normalizedName]) {
            driveMap[normalizedName] = {
              original: originalName, 
              normalized: normalizedName,
              types: [] 
            };
          }
          if (!driveMap[normalizedName].types.includes(assignmentType)) {
             driveMap[normalizedName].types.push(assignmentType);
          }
        }
      }
      Logger.log(`(V21) Qu√©t xong ${parentFolder.getName()}, g√°n lo·∫°i: ${assignmentType}`);
    } catch (e) {
      Logger.log(`(V21) L·ªói khi qu√©t Folder ID ${folderId}: ${e.message}`);
    }
  };

  scanParentFolder(PARENT_FOLDER_THU_ID, "THU");
  scanParentFolder(PARENT_FOLDER_SUN_ID, "SUN");
  scanParentFolder(PARENT_FOLDER_OTH_ID, "OTH");

  for (const key in driveMap) {
    driveList.push(driveMap[key]);
  }

  Logger.log(`(V21) X√¢y d·ª±ng b·∫£n ƒë·ªì (List) ho√†n t·∫•t. T√¨m th·∫•y ${driveList.length} h·ªçc sinh.`);
  return driveList;
}

/**
 * H√ÄM (H·ªñ TR·ª¢ V21): Chuy·ªÉn ƒë·ªïi Key ("THU") sang T√™n Form ƒë·∫ßy ƒë·ªß
 */
function convertDriveTypeToAssignmentType(typeKey) {
  if (typeKey === "THU") return ASSIGNMENT_TYPE_THU;
  if (typeKey === "SUN") return ASSIGNMENT_TYPE_SUN;
  if (typeKey === "OTH") return ASSIGNMENT_TYPE_OTH;
  return ASSIGNMENT_TYPE_OTH;
}


/**
 * H√ÄM 5: (*** C·∫¨P NH·∫¨T V21/V23 ***) 
 * ƒê·ªêI SO√ÅT ƒê·ªäNH K·ª≤ (ƒê∆°n gi·∫£n h√≥a - Ch·ªâ Check, Kh√¥ng H·ªßy Check)
 * (*** C·∫¨P NH·∫¨T V24: C·∫≠p nh·∫≠t t√™n h√†m (context) ***)
 */
function reconcileCheckboxes() {
  Logger.log("--- (V24) B·∫Øt ƒë·∫ßu ƒê·ªëi so√°t ƒê·ªãnh k·ª≥ (LOGIC LAST-TWO, CH·ªà CHECK) ---");
  
  try {
    const driveList = buildDriveStudentMap_V21();

    if (driveList.length === 0) {
      Logger.log("(V24) Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c h·ªçc sinh n√†o tr√™n Drive. K·∫øt th√∫c ƒë·ªëi so√°t.");
      return;
    }

    Logger.log(`(V24) B·∫Øt ƒë·∫ßu Giai ƒëo·∫°n 1 (Kh·ªõp Drive -> Sheet) cho ${driveList.length} th∆∞ m·ª•c...`);

    for (const driveItem of driveList) {
      const driveName = driveItem.original;
      const driveTypes = driveItem.types;

      if (!driveTypes || driveTypes.length === 0) continue;

      for (const typeKey of driveTypes) {
        const assignmentType = convertDriveTypeToAssignmentType(typeKey); 
        
        Logger.log(`(V24) ƒêang ƒë·ªëi so√°t: T√™n Drive "${driveName}" cho Lo·∫°i "${assignmentType}"`);
        
        // G·ªçi "C√¥ng c·ª• So kh·ªõp" (H√†m 2 - V24)
        findAndMarkCheckbox(
          driveName, 
          assignmentType, 
          "reconcile-v24", // (Context m·ªõi V24)
          false 
        );
      }
    }

    Logger.log("--- (V24) Ho√†n t·∫•t ƒê·ªëi so√°t (LOGIC LAST-TWO, CH·ªà CHECK). ---");

  } catch (err) {
    Logger.log(`(V24) L·ªñI NGHI√äM TR·ªåNG trong reconcileCheckboxes: ${err.message}`);
  }
}


// ==================================================================
// C√ÅC H√ÄM H·ªñ TR·ª¢ M·ªöI (V13 / V14 / V14.3 / V20 / V21 / V23 / V24)
// ==================================================================

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V14): G·ª≠i Email S·ª≠a l·ªói (khi t·ª± ƒë·ªông ƒëo√°n)
 * (Gi·ªØ nguy√™n V23)
 */
function sendCorrectionEmail(suspectName, sheetName, sheetTabId, checkboxCol, bestGuess, otherCandidates) {
  if (!RECIPIENT_EMAIL) return;

  try {
    const webAppUrl = ScriptApp.getService().getUrl();
    if (!webAppUrl) {
      Logger.log("L·ªñI: Script CH∆ØA ƒê∆Ø·ª¢C TRI·ªÇN KHAI D∆Ø·ªöI D·∫†NG WEB APP. Kh√¥ng th·ªÉ g·ª≠i email t∆∞∆°ng t√°c.");
      return;
    }
    
    let buttonsHtml = "";
    otherCandidates.forEach(candidate => {
      
      const location = candidate.location; 
      if (!location) return; 

      const bestGuessLocation = bestGuess.location;
      if (!bestGuessLocation) {
         Logger.log(`L·ªñI (sendCorrectionEmail): bestGuess ${bestGuess.original} kh√¥ng c√≥ 'location'.`);
         return; 
      }
      
      const url = new URL(webAppUrl);
      url.searchParams.append("action", "correct");
      url.searchParams.append("sheetTabId", location.sheetTabId); 
      url.searchParams.append("formName", suspectName);
      url.searchParams.append("oldRow", bestGuessLocation.row);
      url.searchParams.append("oldCol", bestGuessLocation.checkboxCol);
      url.searchParams.append("newRow", location.row);
      url.searchParams.append("newCol", location.checkboxCol);
      
      buttonsHtml += `
        <a href="${url.href}" target="_blank" style="
          display: inline-block; padding: 10px 15px; margin: 5px 5px 5px 0;
          background-color: #ffc107; color: #212529; text-decoration: none;
          border-radius: 5px; font-weight: bold; border: 1px solid #e0a800;
        ">
          Ch·ªçn: ${candidate.original}
        </a>
      `;
    });

    const subject = `[C·∫¢NH B√ÅO] ƒê√£ t·ª± ƒë·ªông ƒëo√°n t√™n n·ªôp b√†i: "${suspectName}"`;
    const bodyHtml = `
      <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6;">
          <h2>H·ªá th·ªëng ƒë√£ t·ª± ƒë·ªông suy ƒëo√°n</h2>
          <p>B√†i n·ªôp t·ª´ t√™n: <strong>"${suspectName}"</strong> (t·ª´ Form ho·∫∑c Drive) ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông kh·ªõp v√† ƒë√°nh d·∫•u l√†:</p>
          <p style="
            font-size: 1.2em; font-weight: bold; color: #28a745; padding: 10px;
            background-color: #f0f9f2; border-left: 5px solid #28a745;
          ">
            ${bestGuess.original} (Sheet: ${sheetName})
          </p>
          <p>N·∫øu suy ƒëo√°n n√†y l√† <strong>SAI</strong>, vui l√≤ng ch·ªçn l·∫°i t√™n ch√≠nh x√°c b√™n d∆∞·ªõi. (N·∫øu kh√¥ng l√†m g√¨, suy ƒëo√°n s·∫Ω ƒë∆∞·ª£c gi·ªØ nguy√™n).</p>
          <div style="padding: 10px 0;">
            ${buttonsHtml}
          </div>
          <p style="font-size: 0.9em; color: #777;">
            (N·∫øu t·∫•t c·∫£ ƒë·ªÅu sai, vui l√≤ng b·ªè qua email n√†y v√† ki·ªÉm tra th·ªß c√¥ng tr√™n Google Sheet.)
          </p>
        </body>
      </html>
    `;

    MailApp.sendEmail({
      to: RECIPIENT_EMAIL,
      subject: subject,
      htmlBody: bodyHtml
    });
    
    Logger.log(`ƒê√£ g·ª≠i email C·∫¢NH B√ÅO & S·ª¨A L·ªñI (ƒêo√°n ${bestGuess.original}) cho "${suspectName}".`);

  } catch (e) {
    Logger.log(`L·ªói khi g·ª≠i email s·ª≠a l·ªói: ${e.message}`);
  }
}


/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V23): Chu·∫©n h√≥a chu·ªói (Lowercase, B·ªè d·∫•u, X√≥a T·∫§T C·∫¢ ngo·∫∑c, X√≥a Ti·ªÅn t·ªë)
 * (Gi·ªØ nguy√™n V23)
 */
function normalizeString(str) {
  if (!str || typeof str !== 'string') {
    return "";
  }
  
  const prefixRegex = new RegExp(`^(${PREFIX_KEYWORDS_TO_REMOVE.join("|")})\\s+`, 'g');

  let s = str.toLowerCase(); // (V23) Lu√¥n lowercase ƒê·∫¶U TI√äN

  return s.trim()
          .replace(prefixRegex, "") 
          .replace(/[\(\[\{].*?[\)\]\}]/g, "") 
          .replace(/[-_,\/\\|]/g, ' ')
          .normalize('NFD') 
          .replace(/[\u0300-\u036f]/g, '') 
          .replace(/ƒë/g, 'd') 
          .replace(/\s+/g, ' ') 
          .trim(); 
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V11): T√≠nh kho·∫£ng c√°ch Levenshtein (ƒêo l∆∞·ªùng l·ªói Typo)
 * (Gi·ªØ nguy√™n V13)
 */
function levenshteinDistance(s1, s2) {
  s1 = s1 || "";
  s2 = s2 || "";
  const m = s1.length;
  const n = s2.length;
  let dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));

  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      let cost = (s1[i - 1] === s2[j - 1]) ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,      // Deletion (X√≥a)
        dp[i][j - 1] + 1,      // Insertion (Ch√®n)
        dp[i - 1][j - 1] + cost // Substitution (Thay th·∫ø)
      );
    }
  }
  return dp[m][n];
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V14): T√¨m m·ªôt trang t√≠nh (tab) b·∫±ng GID c·ªßa n√≥.
 */
function getSheetByTabId(spreadsheet, id) {
  if (!spreadsheet || id == null) return null;
  
  const sheets = spreadsheet.getSheets();
  for (let i = 0; i < sheets.length; i++) {
    if (sheets[i].getSheetId() == id) { 
      return sheets[i];
    }
  }
  return null; // Kh√¥ng t√¨m th·∫•y
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V14.2): Th√™m l·ªùi khen n·ªôp s·ªõm v√†o c·ªôt
 */
function addEarlyComment(sheet, col, row) {
  try {
    if (!col || !row) {
       Logger.log("L·ªói (addEarlyComment): Thi·∫øu c·ªôt ho·∫∑c h√†ng.");
       return;
    }
    const cellAddress = `${col}${row}`;
    const cell = sheet.getRange(cellAddress);
    const currentComment = cell.getValue().toString();
    
    if (currentComment.includes(EARLY_SUBMISSION_COMMENT)) {
      Logger.log(`Nh·∫≠n x√©t n·ªôp s·ªõm ƒë√£ t·ªìn t·∫°i t·∫°i √¥ ${cellAddress}.`);
      return;
    }
    
    const newComment = currentComment ? (currentComment + "\n" + EARLY_SUBMISSION_COMMENT) : EARLY_SUBMISSION_COMMENT;
    cell.setValue(newComment);
    Logger.log(`ƒê√£ th√™m nh·∫≠n x√©t n·ªôp s·ªõm t·∫°i √¥ ${cellAddress}.`);
  
  } catch (err) {
    Logger.log(`L·ªói khi th√™m nh·∫≠n x√©t n·ªôp s·ªõm t·∫°i ${col}${row}: ${err.message}`);
  }
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V14.2): Ki·ªÉm tra xem c√≥ n·ªôp s·ªõm kh√¥ng
 */
function checkIsEarly(submissionDate, deadlineNum, daysEarlyRequired) {
  try {
    const deadlineDay = Math.floor(deadlineNum / 10000); // 3 (Wed)
    const deadlineHour = Math.floor((deadlineNum % 10000) / 100); // 12
    const deadlineMinute = deadlineNum % 100; // 0

    let deadlineDate = new Date(submissionDate.getTime());
    
    const dayOffset = (deadlineDay - submissionDate.getDay() + 7) % 7;
    deadlineDate.setDate(deadlineDate.getDate() + dayOffset);
    deadlineDate.setHours(deadlineHour, deadlineMinute, 0, 0);

    if (deadlineDate.getTime() < submissionDate.getTime()) {
      deadlineDate.setDate(deadlineDate.getDate() + 7); 
    }
    
    const msInDay = 24 * 60 * 60 * 1000;
    const requiredMsEarly = daysEarlyRequired * msInDay;
    
    const timeDifference = deadlineDate.getTime() - submissionDate.getTime();
    
    if (timeDifference >= requiredMsEarly) {
      Logger.log(`Ph√°t hi·ªán N·ªòP S·ªöM! (S·ªõm ${Math.floor(timeDifference / msInDay)} ng√†y so v·ªõi h·∫°n).`);
      return true;
    }
    return false;

  } catch (e) {
    Logger.log(`L·ªói khi ki·ªÉm tra n·ªôp s·ªõm: ${e.message}`);
    return false;
  }
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V14.3): T√¨m v√† cache c·ªôt ∆Øu ƒëi·ªÉm.
 */
function findAndCacheAdvantageColumn(sheet, sheetTabId) {
  const cache = PropertiesService.getScriptProperties();
  const cacheKey = `ADV_COL_GID_${sheetTabId}`; 

  const cachedCol = cache.getProperty(cacheKey);
  if (cachedCol) {
    Logger.log(`(Cache) ƒê√£ t√¨m th·∫•y C·ªôt ∆Øu ƒëi·ªÉm: ${cachedCol}`);
    return (cachedCol === "NONE") ? null : cachedCol;
  }

  Logger.log(`(Cache) Kh√¥ng t√¨m th·∫•y C·ªôt ∆Øu ƒëi·ªÉm, ƒëang qu√©t h√†ng 1 c·ªßa Sheet GID ${sheetTabId}...`);
  try {
    const headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    let foundColLetter = null;

    for (let i = 0; i < headerRow.length; i++) {
      const headerText = normalizeString(headerRow[i]);
      if (!headerText) continue;

      const foundKeyword = ADVANTAGE_KEYWORDS.some(keyword => headerText.includes(keyword));
      
      if (foundKeyword) {
        foundColLetter = colIndexToLetter(i + 1); 
        Logger.log(`(Cache) ƒê√£ t√¨m th·∫•y C·ªôt ∆Øu ƒëi·ªÉm t·∫°i: ${foundColLetter} (Ti√™u ƒë·ªÅ: "${headerRow[i]}")`);
        break; 
      }
    }

    if (foundColLetter) {
      cache.setProperty(cacheKey, foundColLetter);
      return foundColLetter;
    } else {
      Logger.log(`(Cache) Kh√¥ng t√¨m th·∫•y c·ªôt n√†o kh·ªõp t·ª´ kh√≥a [${ADVANTAGE_KEYWORDS.join(", ")}]`);
      cache.setProperty(cacheKey, "NONE"); 
      return null;
    }

  } catch (err) {
    Logger.log(`L·ªói nghi√™m tr·ªçng khi t√¨m C·ªôt ∆Øu ƒëi·ªÉm: ${err.message}`);
    return null;
  }
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V14.3): Chuy·ªÉn ƒë·ªïi s·ªë th·ª© t·ª± c·ªôt sang ch·ªØ c√°i (1 -> A, 2 -> B)
 */
function colIndexToLetter(colIndex) {
  let temp, letter = '';
  while (colIndex > 0) {
    temp = (colIndex - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    colIndex = (colIndex - temp - 1) / 26;
  }
  return letter;
}

/**
 * H√ÄM (H·ªñ TR·ª¢ M·ªöI V20): X√≥a cache email reconcile khi d·ªçn d·∫πp h√†ng tu·∫ßn
 */
function clearReconcileEmailCache(scriptProperties) {
  try {
    const allKeys = scriptProperties.getKeys();
    let deleteCount = 0;
    allKeys.forEach(key => {
      if (key.startsWith("reconcile_email_")) {
        scriptProperties.deleteProperty(key);
        deleteCount++;
      }
    });
    Logger.log(`(V20) ƒê√£ x√≥a ${deleteCount} c·ªù cache email reconcile.`);
  } catch (e) {
    Logger.log(`(V20) L·ªói khi x√≥a cache email: ${e.message}`);
  }
}