/**
 * ============================================================================
 * LIBRARY: Form Automation Script (Standalone Project)
 * ============================================================================
 * 
 * ƒê√ÇY L√Ä LIBRARY D√ôNG CHUNG CHO T·∫§T C·∫¢ C√ÅC L·ªöP
 * 
 * H∆∞·ªõng d·∫´n setup:
 * 1. T·∫°o standalone Apps Script project m·ªõi
 * 2. Copy to√†n b·ªô code n√†y v√†o
 * 3. B·∫≠t Service "Drive API" (Add a service ‚Üí Drive API ‚Üí Add)
 * 4. Deploy ‚Üí New deployment ‚Üí Type: Library
 * 5. Copy Script ID v√† phi√™n b·∫£n
 * 6. Trong m·ªói Form template/l·ªõp:
 *    - Resources ‚Üí Libraries ‚Üí Add library (paste Script ID)
 *    - Ch·ªçn phi√™n b·∫£n m·ªõi nh·∫•t
 *    - Identifier: "FormLib"
 * 
 * Khi c·∫ßn update:
 * - S·ª≠a code trong library n√†y
 * - Deploy phi√™n b·∫£n m·ªõi
 * - T·∫§T C·∫¢ l·ªõp t·ª± ƒë·ªông d√πng code m·ªõi!
 * 
 * ============================================================================
 */

// ==================================================================
// TI·ªÜN √çCH: T·ª∞ ƒê·ªòNG ƒê·ªîI T√äN APPS SCRIPT PROJECT
// ==================================================================

/**
 * H√†m t·ª± ƒë·ªông ƒë·ªïi t√™n Apps Script Project c·ªßa Form n√†y
 * G·ªåI TH·ª¶C√îNG 1 L·∫¶N sau khi t·∫°o l·ªõp m·ªõi ƒë·ªÉ ƒë·∫∑t t√™n project
 * 
 * C√°ch d√πng:
 * 1. M·ªü Apps Script editor c·ªßa Form
 * 2. Run ‚Üí autoRenameScriptProject
 * 3. Authorize l·∫ßn ƒë·∫ßu
 * 4. F5 reload page ƒë·ªÉ th·∫•y t√™n m·ªõi
 */
function autoRenameScriptProject() {
  try {
    // L·∫•y t√™n form hi·ªán t·∫°i
    const form = FormApp.getActiveForm();
    const formTitle = form.getTitle();
    
    // T·∫°o t√™n project: [FormScript] T√äN_L·ªöP
    const scriptId = ScriptApp.getScriptId();
    const projectName = `[FormScript] ${formTitle}`;
    
    // G·ªçi Drive API ƒë·ªÉ ƒë·ªïi t√™n (C·∫ßn b·∫≠t Service "Drive API" tr∆∞·ªõc)
    Drive.Files.update({ name: projectName }, scriptId);
    
    Logger.log(`‚úÖ ƒê√£ ƒë·ªïi t√™n Project th√†nh: "${projectName}"`);
    Logger.log("L∆∞u √Ω: Reload page (F5) ƒë·ªÉ th·∫•y t√™n m·ªõi tr√™n giao di·ªán.");
    
    Browser.msgBox(
      "Th√†nh c√¥ng!",
      `ƒê√£ ƒë·ªïi t√™n Project th√†nh: "${projectName}"\n\nReload page (F5) ƒë·ªÉ th·∫•y thay ƒë·ªïi.`,
      Browser.Buttons.OK
    );
  } catch (e) {
    Logger.log("‚ùå L·ªói: " + e.message);
    Logger.log("üëâ H√£y ch·∫Øc ch·∫Øn ƒë√£ b·∫≠t 'Drive API' trong Services.");
    
    Browser.msgBox(
      "L·ªói",
      "Kh√¥ng th·ªÉ ƒë·ªïi t√™n Project.\n\nƒê·∫£m b·∫£o ƒë√£ b·∫≠t 'Drive API' trong Services (g√≥c tr√°i).",
      Browser.Buttons.OK
    );
  }
}

/**
 * H√†m setup nhanh - G·ªçi t·ª± ƒë·ªông l·∫ßn ƒë·∫ßu ƒë·ªÉ c·∫•p quy·ªÅn v√† ƒë·ªïi t√™n project
 * G·ªåI TH·ª¶C√îNG 1 L·∫¶N ho·∫∑c ƒë∆∞·ª£c g·ªçi t·ª´ quickSetup t·ªïng h·ª£p
 * 
 * C√°ch d√πng:
 * 1. Run ‚Üí quickSetupForm
 * 2. Authorize t·∫•t c·∫£ quy·ªÅn c·∫ßn thi·∫øt
 * 3. Xong!
 */
function quickSetupForm() {
  try {
    Logger.log("üöÄ ƒêang ch·∫°y Quick Setup cho Form...");
    
    // 1. ƒê·ªïi t√™n project
    Logger.log("1. ƒê·ªïi t√™n Apps Script Project...");
    autoRenameScriptProject();
    
    // 2. Ki·ªÉm tra config sheet
    Logger.log("2. Ki·ªÉm tra k·∫øt n·ªëi Sheet...");
    const ss = getConfigSpreadsheet();
    if (!ss) {
      Logger.log("‚ö†Ô∏è Ch∆∞a link ƒë∆∞·ª£c Sheet. H√£y link th·ªß c√¥ng.");
    } else {
      Logger.log(`‚úÖ ƒê√£ k·∫øt n·ªëi Sheet: ${ss.getName()}`);
    }
    
    // 3. Load configs
    Logger.log("3. T·∫£i c·∫•u h√¨nh...");
    const configs = ConfigManager.loadAll();
    Logger.log(`‚úÖ T·∫£i ƒë∆∞·ª£c ${configs.length} c·∫•u h√¨nh`);
    
    Logger.log("‚úÖ Quick Setup ho√†n t·∫•t!");
    
  } catch (e) {
    Logger.log("‚ùå L·ªói: " + e.message);
    Browser.msgBox("‚ùå L·ªói", "L·ªói trong qu√° tr√¨nh setup: " + e.message, Browser.Buttons.OK);
  }
}

/**
 * ƒê·ªëi so√°t checkboxes - So s√°nh danh s√°ch n·ªôp b√†i gi·ªØa Sheet v√† Drive
 * G·ªåI ƒê·ªäNH K·ª≤ (khuy·∫øn ngh·ªã: m·ªói 30 ph√∫t) ho·∫∑c TH·ª¶ C√îNG khi c·∫ßn
 * 
 * Ch·ª©c nƒÉng:
 * - Qu√©t t·∫•t c·∫£ folders b√†i t·∫≠p tr√™n Drive
 * - So s√°nh v·ªõi danh s√°ch h·ªçc sinh trong Sheet
 * - T·ª± ƒë·ªông tick checkbox cho h·ªçc sinh ƒë√£ n·ªôp nh∆∞ng ch∆∞a ƒë√°nh d·∫•u
 * - H·ªó tr·ª£ 4 phases matching: Exact ‚Üí Last 2 words ‚Üí Normalized ‚Üí Typo detection
 * 
 * C√°ch d√πng:
 * 1. T·ª± ƒë·ªông: T·∫°o trigger Time-driven ch·∫°y m·ªói 30 ph√∫t
 * 2. Th·ªß c√¥ng: Run ‚Üí reconcileCheckboxes
 * 3. T·ª´ wrapper: FormLib.reconcileCheckboxes(classFolderId)
 * 
 * @param {string} classFolderId - (Optional) Class Folder ID n·∫øu c·∫ßn t·ª± ƒë·ªông ƒë·ªìng b·ªô folder IDs
 */
function reconcileCheckboxes(classFolderId) {
  Logger.log("--- B·∫Øt ƒë·∫ßu ƒê·ªëi so√°t ƒë·ªãnh k·ª≥ ---");
  
  let configs = ConfigManager.loadAll();
  
  // Ki·ªÉm tra xem c√≥ config n√†o thi·∫øu folderId kh√¥ng
  const missingFolderIds = configs.filter(c => !c.isAttendance && !c.folderId);
  
  if (missingFolderIds.length > 0) {
    Logger.log(`‚ö†Ô∏è Ph√°t hi·ªán ${missingFolderIds.length} assignments thi·∫øu Folder ID`);
    
    if (!classFolderId) {
      Logger.log(`‚ùå KH√îNG TH·ªÇ T·ª∞ ƒê·ªòNG ƒê·ªíNG B·ªò: Thi·∫øu Class Folder ID`);
      Logger.log(`üìã C√°c b∆∞·ªõc kh·∫Øc ph·ª•c:`);
      Logger.log(`1. L·∫•y Class Folder ID t·ª´ cell I3 trong Sheet Config`);
      Logger.log(`2. G·ªçi: FormLib.reconcileCheckboxes(classFolderId)`);
      Logger.log(`   HO·∫∂C ch·∫°y syncFolderIdsFromSheet(classFolderId) tr∆∞·ªõc`);
      return;
    }
    
    Logger.log(`üîÑ ƒêang t·ª± ƒë·ªông ƒë·ªìng b·ªô Folder IDs...`);
    
    const syncSuccess = syncFolderIdsFromSheet(classFolderId);
    
    if (syncSuccess) {
      Logger.log(`‚úÖ ƒê·ªìng b·ªô th√†nh c√¥ng! ƒêang reload configs...`);
      // Reload configs sau khi ƒë·ªìng b·ªô
      configs = ConfigManager.loadAll();
    } else {
      Logger.log(`‚ùå ƒê·ªìng b·ªô th·∫•t b·∫°i. C√°c b∆∞·ªõc kh·∫Øc ph·ª•c:`);
      Logger.log(`1. Ki·ªÉm tra Class Folder ID c√≥ ƒë√∫ng kh√¥ng`);
      Logger.log(`2. ƒê·∫£m b·∫£o ƒë√£ t·∫°o c√°c assignment folders tr√™n Drive`);
      Logger.log(`3. Ch·∫°y l·∫°i v·ªõi: FormLib.reconcileCheckboxes(classFolderId)`);
      return;
    }
  }
  
  let totalReconciled = 0;
  
  for (const config of configs) {
    if (config.isAttendance || !config.folderId) {
      if (config.isAttendance) {
        Logger.log(`‚è≠Ô∏è B·ªè qua "${config.name}" (ƒêi·ªÉm danh)`);
      } else {
        Logger.log(`‚ö†Ô∏è B·ªé QUA "${config.name}" - CH∆ØA C√ì FOLDER_ID! H√£y link folder tr√™n giao di·ªán web tr∆∞·ªõc.`);
      }
      continue;
    }
    
    try {
      Logger.log(`\nüìã ƒê·ªëi so√°t "${config.name}"...`);
      
      const ss = getConfigSpreadsheet();
      if (!ss) {
        Logger.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Sheet.`);
        continue;
      }
      
      let sheet;
      if (config.sheetTabId) {
        sheet = getSheetByTabId(ss, config.sheetTabId);
      } else {
        sheet = ss.getSheetByName(config.sheetName);
      }
      
      if (!sheet) {
        Logger.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y sheet "${config.sheetName}"`);
        continue;
      }
      
      // L·∫•y danh s√°ch h·ªçc sinh trong sheet
      const nameColumnValues = sheet.getRange(`B1:B${sheet.getLastRow()}`).getValues();
      const checkboxValues = sheet.getRange(`G1:G${sheet.getLastRow()}`).getValues();
      
      const sheetStudents = [];
      for (let i = 1; i < nameColumnValues.length; i++) {  // B·∫Øt ƒë·∫ßu t·ª´ i=1 ƒë·ªÉ b·ªè qua header
        const cellValue = nameColumnValues[i][0];
        const isChecked = checkboxValues[i][0];
        
        if (!cellValue || typeof cellValue !== 'string') continue;
        if (cellValue.toLowerCase().includes('t√™n') || cellValue.toLowerCase().includes('name')) continue;
        
        sheetStudents.push({
          name: cellValue.trim(),
          row: i + 1,
          isChecked: isChecked === true
        });
      }
      
      Logger.log(`  üìä T√¨m th·∫•y ${sheetStudents.length} h·ªçc sinh trong sheet`);
      
      // Qu√©t folder tr√™n Drive ƒë·ªÉ t√¨m ai ƒë√£ n·ªôp
      const folder = DriveApp.getFolderById(config.folderId);
      const subfolders = folder.getFolders();
      const submittedStudents = new Set();
      
      while (subfolders.hasNext()) {
        const subfolder = subfolders.next();
        const studentName = subfolder.getName().replace(/^\[Qu√° h·∫°n\]\s*/i, '').trim();
        submittedStudents.add(studentName);
      }
      
      Logger.log(`  üìÅ T√¨m th·∫•y ${submittedStudents.size} th∆∞ m·ª•c h·ªçc sinh tr√™n Drive`);
      
      // ƒê·ªëi so√°t: So s√°nh sheet vs Drive theo 4 b∆∞·ªõc
      let fixed = 0;
      for (const student of sheetStudents) {
        let matchedName = null;
        let matchLevel = null;
        
        // ========== PHASE 1: Exact match (lowercase) ==========
        for (const submittedName of submittedStudents) {
          if (student.name.toLowerCase().trim() === submittedName.toLowerCase().trim()) {
            matchedName = submittedName;
            matchLevel = "Phase 1 (Exact)";
            break;
          }
        }
        
        // ========== PHASE 2: Last 2 words match (with diacritics) ==========
        if (!matchedName) {
          const studentWords = student.name.toLowerCase().split(/\s+/).filter(Boolean);
          const studentLastTwo = studentWords.length >= 2 ? studentWords.slice(-2).join(' ') : null;
          
          if (studentLastTwo) {
            for (const submittedName of submittedStudents) {
              const submittedWords = submittedName.toLowerCase().split(/\s+/).filter(Boolean);
              const submittedLastTwo = submittedWords.length >= 2 ? submittedWords.slice(-2).join(' ') : null;
              
              if (submittedLastTwo && studentLastTwo === submittedLastTwo) {
                matchedName = submittedName;
                matchLevel = "Phase 2 (Last 2 words)";
                break;
              }
            }
          }
        }
        
        // ========== PHASE 3: Normalized match (remove diacritics) ==========
        if (!matchedName) {
          const normalizedStudent = normalizeString(student.name);
          const normalizedStudentWords = normalizedStudent.split(/\s+/).filter(Boolean);
          const normalizedStudentLastTwo = normalizedStudentWords.length >= 2 ? normalizedStudentWords.slice(-2).join(' ') : normalizedStudent;
          
          for (const submittedName of submittedStudents) {
            const normalizedSubmitted = normalizeString(submittedName);
            const normalizedSubmittedWords = normalizedSubmitted.split(/\s+/).filter(Boolean);
            const normalizedSubmittedLastTwo = normalizedSubmittedWords.length >= 2 ? normalizedSubmittedWords.slice(-2).join(' ') : normalizedSubmitted;
            
            // So s√°nh both directions
            if (normalizedStudentLastTwo === normalizedSubmittedLastTwo ||
                normalizedStudent === normalizedSubmitted) {
              matchedName = submittedName;
              matchLevel = "Phase 3 (Normalized)";
              break;
            }
          }
        }
        
        // ========== PHASE 4: Typo detection (Levenshtein distance) ==========
        if (!matchedName) {
          const normalizedStudent = normalizeString(student.name);
          let typoCandidates = [];
          
          for (const submittedName of submittedStudents) {
            const normalizedSubmitted = normalizeString(submittedName);
            const distance = levenshteinDistance(normalizedStudent, normalizedSubmitted);
            
            if (distance > 0 && distance <= TYPO_THRESHOLD) {
              typoCandidates.push({
                name: submittedName,
                distance: distance
              });
            }
          }
          
          if (typoCandidates.length > 0) {
            typoCandidates.sort((a, b) => a.distance - b.distance);
            matchedName = typoCandidates[0].name;
            matchLevel = `Phase 4 (Typo, distance: ${typoCandidates[0].distance})`;
          }
        }
        
        // ========== C·∫¨P NH·∫¨T CHECKBOX ==========
        if (matchedName) {
          if (!student.isChecked) {
            // ƒê√£ n·ªôp nh∆∞ng checkbox ch∆∞a tick -> S·ª≠a
            const checkboxCell = sheet.getRange(`G${student.row}`);
            checkboxCell.setValue(true);
            Logger.log(`  ‚úÖ S·ª≠a: "${student.name}" ‚Üí "${matchedName}" (${matchLevel})`);
            fixed++;
          }
          // N·∫øu checkbox ƒë√£ tick ƒë√∫ng th√¨ kh√¥ng c·∫ßn s·ª≠a
        } else {
          // Ch∆∞a t√¨m th·∫•y folder
          if (student.isChecked) {
            // Checkbox ƒë√£ tick nh∆∞ng kh√¥ng c√≥ folder -> C·∫£nh b√°o
            Logger.log(`  ‚ö†Ô∏è Nghi v·∫•n: "${student.name}" checkbox ƒë√£ tick nh∆∞ng kh√¥ng c√≥ folder`);
          }
        }
      }
      
      Logger.log(`  ‚ú® Ho√†n t·∫•t: ${fixed} checkbox ƒë∆∞·ª£c s·ª≠a`);
      totalReconciled += fixed;
      
    } catch (err) {
      Logger.log(`‚ùå L·ªói ƒë·ªëi so√°t "${config.name}": ${err.message}`);
    }
  }
  
  Logger.log(`\n--- Ho√†n t·∫•t ƒê·ªëi so√°t: ${totalReconciled} checkbox ƒë∆∞·ª£c s·ª≠a ---`);
}

// ==================================================================
// PH·∫¶N C·∫§U H√åNH C∆† B·∫¢N
// ==================================================================

const CONFIG_SHEET_NAME = "C·∫•u H√¨nh";
const TEMPLATE_SHEET_NAME = "(M·∫´u) B·∫£ng nh·∫≠n x√©t";
const ATTENDANCE_SHEET_NAME = "ƒêi·ªÉm danh";

// C·∫•u h√¨nh Sheet c·ªôt
const CONFIG_COL = {
  NAME: 0,        // A: T√™n B√†i T·∫≠p
  CLASS_TIME: 1,  // B: Th·ªùi gian v√†o gi·ªù d·∫°y
  START_TIME: 2,  // C: B·∫Øt ƒë·∫ßu (cho ph√©p n·ªôp)
  DEADLINE: 3,    // D: H·∫°n ch√≥t
  AUTO_CLEAN: 4,  // E: D·ªçn d·∫πp (checkbox)
  SHEET_NAME: 5   // F: T√™n Sheet
};

// C·∫•u h√¨nh Sheet nh·∫≠n x√©t
const SHEET_COL = {
  NAME: "B",      // C·ªôt t√™n h·ªçc sinh
  CHECKBOX: "G",  // C·ªôt checkbox
  NOTE: "F"       // C·ªôt ghi ch√∫
};

// C√°c constants gi·ªØ nguy√™n
const GRACE_PERIOD_MINUTES = 10;
const TYPO_THRESHOLD = 2;
const EARLY_DAYS_REQUIRED = 2;
const CLEANUP_WINDOW_MIN = 30;
const CLEANUP_WINDOW_MAX = 60;

const STUDENT_NAME_QUESTION_TITLE = "T√™n h·ªçc sinh (ch·ªâ ƒëi·ªÅn t√™n ƒë·ªám v√† t√™n):";
const ASSIGNMENT_TYPE_QUESTION_TITLE = "Ch·ªçn b√†i t·∫≠p:";

const EARLY_SUBMISSION_COMMENT = "L√†m b√†i t·∫≠p v·ªÅ nh√† chƒÉm ch·ªâ, tinh th·∫ßn h·ªçc t·∫≠p t·ªët, l√†m v√† n·ªôp BTVN t·ª´ s·ªõm.";
const LATE_SUBMISSION_COMMENT = "N·ªôp mu·ªôn";

const ADVANTAGE_KEYWORDS = [
  "∆∞u ƒëi·ªÉm", "∆∞u", "t·ªët", "gi·ªèi", "khen", "nh·∫≠n x√©t",
  "t√≠ch c·ª±c", "ph√™", "th∆∞·ªüng", "c·ªông"
];

const PREFIX_KEYWORDS_TO_REMOVE = ["con", "em", "b·∫°n", "ch√°u", "hs", "hoc sinh"];

// ==================================================================
// CONFIG MANAGER - ƒê·ªåC C·∫§U H√åNH T·ª™ SHEET
// ==================================================================

/**
 * Helper: L·∫•y Spreadsheet t·ª´ Script Properties ho·∫∑c form destination
 */
function getConfigSpreadsheet() {
  // Th·ª≠ 1: L·∫•y t·ª´ Script Properties (ƒë∆∞·ª£c quickSetup t·ª± ƒë·ªông l∆∞u)
  const scriptProperties = PropertiesService.getScriptProperties();
  const sheetId = scriptProperties.getProperty('SHEET_ID');
  
  if (sheetId) {
    try {
      return SpreadsheetApp.openById(sheetId);
    } catch (e) {
      Logger.log(`C·∫£nh b√°o: Kh√¥ng m·ªü ƒë∆∞·ª£c Sheet b·∫±ng ID t·ª´ Script Properties: ${e.message}`);
    }
  }
  
  // Th·ª≠ 2: Fallback sang form destination (n·∫øu ƒë√£ link)
  try {
    const form = FormApp.getActiveForm();
    
    if (form) {
      const destinationId = form.getDestinationId();
      
      if (destinationId) {
        return SpreadsheetApp.openById(destinationId);
      }
    }
  } catch (e) {
    Logger.log(`C·∫£nh b√°o: Form ch∆∞a c√≥ destination: ${e.message}`);
  }
  
  // Th·ª≠ 3: Fallback sang getActiveSpreadsheet (cho c√°c script ch·∫°y t·ª´ sheet)
  try {
    return SpreadsheetApp.getActiveSpreadsheet();
  } catch (e) {
    Logger.log(`L·ªói: Kh√¥ng th·ªÉ l·∫•y spreadsheet: ${e.message}`);
    return null;
  }
}

class ConfigManager {
  static loadAll() {
    try {
      const ss = getConfigSpreadsheet();
      
      if (!ss) {
        Logger.log('L·ªñI: Kh√¥ng t√¨m th·∫•y Sheet Config. Vui l√≤ng ch·∫°y quickSetup() ho·∫∑c link form v·ªõi sheet.');
        return [];
      }
      
      const configSheet = ss.getSheetByName(CONFIG_SHEET_NAME);
      
      if (!configSheet) {
        Logger.log(`C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y sheet "${CONFIG_SHEET_NAME}". H·ªá th·ªëng s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.`);
        return [];
      }
      
      const lastRow = configSheet.getLastRow();
      if (lastRow < 2) {
        Logger.log('Kh√¥ng c√≥ config n√†o trong sheet. H·ªá th·ªëng ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.');
        return [];
      }
      
      const dataRange = configSheet.getRange(2, 1, lastRow - 1, 7); // ƒê·ªçc 7 c·ªôt (A-G)
      const values = dataRange.getValues();
      const configs = [];
      
      for (let i = 0; i < values.length; i++) {
        const row = values[i];
        
        if (!row[CONFIG_COL.NAME]) continue;
        
        const config = {
          name: row[CONFIG_COL.NAME].toString().trim(),
          classTime: this.parseMultiSchedule(row[CONFIG_COL.CLASS_TIME]),
          startTime: row[CONFIG_COL.START_TIME] ? this.parseMultiSchedule(row[CONFIG_COL.START_TIME]) : [],
          deadline: row[CONFIG_COL.DEADLINE] ? this.parseMultiSchedule(row[CONFIG_COL.DEADLINE]) : [],
          autoCleanup: row[CONFIG_COL.AUTO_CLEAN] === true,
          sheetName: row[CONFIG_COL.SHEET_NAME] ? row[CONFIG_COL.SHEET_NAME].toString().trim() : null,
          folderId: row[6] ? row[6].toString().trim() : null, // M·ªöI: ƒê·ªçc t·ª´ c·ªôt G (index 6)
          isAttendance: row[CONFIG_COL.NAME].toString().trim() === ATTENDANCE_SHEET_NAME
        };
        
        configs.push(config);
        Logger.log(`Loaded config: ${config.name} (Sheet: ${config.sheetName}, Folder: ${config.folderId}, Attendance: ${config.isAttendance})`);
      }
      
      return configs;
      
    } catch (err) {
      Logger.log(`L·ªói khi load config: ${err.message}`);
      return [];
    }
  }
  
  static parseMultiSchedule(scheduleStr) {
    if (!scheduleStr || typeof scheduleStr !== 'string') return [];
    
    const schedules = [];
    const parts = scheduleStr.split(/[;,]/).map(s => s.trim()).filter(Boolean);
    
    for (const part of parts) {
      // H·ªó tr·ª£ CN ho·∫∑c T1-T7
      const match = part.match(/^(CN|T[1-7])-(\d{1,2}):(\d{2})$/);
      if (!match) {
        Logger.log(`C·∫¢NH B√ÅO: Format th·ªùi gian kh√¥ng h·ª£p l·ªá: "${part}". H·ªó tr·ª£: CN-18:00, T1-18:00, ..., T7-18:00 (ngƒÉn c√°ch b·ªüi ; ho·∫∑c ,)`);
        continue;
      }
      
      // Chuy·ªÉn ƒë·ªïi CN/T1-T7 th√†nh s·ªë 0-6 (0=CN/T1, 1=T2, ..., 6=T7)
      let dayOfWeek;
      if (match[1] === 'CN') {
        dayOfWeek = 0;  // Ch·ªß Nh·∫≠t
      } else {
        const tNum = parseInt(match[1].substring(1), 10);
        dayOfWeek = tNum - 1;  // T1->0, T2->1, ..., T7->6
      }
      
      const hour = parseInt(match[2], 10);
      const minute = parseInt(match[3], 10);
      
      schedules.push({
        day: dayOfWeek,
        hour: hour,
        minute: minute,
        timeNum: (dayOfWeek * 10000) + (hour * 100) + minute,
        original: part
      });
    }
    
    return schedules;
  }
  
  static findByName(assignmentName) {
    const configs = this.loadAll();
    return configs.find(c => c.name === assignmentName) || null;
  }
  
  static findByFolderId(folderId) {
    const configs = this.loadAll();
    return configs.find(c => c.folderId === folderId) || null;
  }
  
  static saveFormId(assignmentName, formId) {
    const props = PropertiesService.getScriptProperties();
    props.setProperty(`CONFIG_${assignmentName}_FORM_ID`, formId);
  }
  
  static saveFolderId(assignmentName, folderId) {
    const props = PropertiesService.getScriptProperties();
    props.setProperty(`CONFIG_${assignmentName}_FOLDER_ID`, folderId);
  }
  
  static saveSheetTabId(assignmentName, sheetTabId) {
    const props = PropertiesService.getScriptProperties();
    props.setProperty(`CONFIG_${assignmentName}_SHEET_TAB_ID`, sheetTabId);
  }
  
  static getSubmissionStatus(config, now, withGrace = true) {
    if (config.isAttendance || config.deadline.length === 0) {
      return "OnTime";
    }
    
    const realDay = now.getDay();
    const realHour = now.getHours();
    const realMinute = now.getMinutes();
    const realTimeNum = (realDay * 10000) + (realHour * 100) + realMinute;
    
    const adjustedTime = new Date(now.getTime() - GRACE_PERIOD_MINUTES * 60000);
    const adjustedDay = adjustedTime.getDay();
    const adjustedHour = adjustedTime.getHours();
    const adjustedMinute = adjustedTime.getMinutes();
    const adjustedTimeNum = (adjustedDay * 10000) + (adjustedHour * 100) + adjustedMinute;
    
    for (let i = 0; i < config.startTime.length; i++) {
      const start = config.startTime[i];
      const end = config.deadline[i] || config.deadline[0];
      
      const inWindow = this.isTimeInRange(realTimeNum, start.timeNum, end.timeNum);
      
      if (inWindow) {
        if (withGrace && adjustedTimeNum <= end.timeNum) {
          return "OnTime";
        } else if (realTimeNum <= end.timeNum) {
          return "LateGrace";
        } else {
          return "Overdue";
        }
      }
    }
    
    return "Overdue";
  }
  
  static isTimeInRange(timeNum, startNum, endNum) {
    if (startNum <= endNum) {
      return timeNum >= startNum && timeNum <= endNum;
    } else {
      return timeNum >= startNum || timeNum <= endNum;
    }
  }
  
  static isEarlySubmission(config, now) {
    if (config.isAttendance || config.deadline.length === 0) return false;
    
    const realTimeNum = (now.getDay() * 10000) + (now.getHours() * 100) + now.getMinutes();
    let closestDeadline = null;
    let minDiff = Infinity;
    
    for (const deadline of config.deadline) {
      let diff = deadline.timeNum - realTimeNum;
      if (diff < 0) diff += 70000;
      
      if (diff < minDiff) {
        minDiff = diff;
        closestDeadline = deadline;
      }
    }
    
    if (!closestDeadline) return false;
    
    const msInDay = 24 * 60 * 60 * 1000;
    const requiredMsEarly = EARLY_DAYS_REQUIRED * msInDay;
    
    let deadlineDate = new Date(now.getTime());
    const dayOffset = (closestDeadline.day - now.getDay() + 7) % 7;
    deadlineDate.setDate(deadlineDate.getDate() + dayOffset);
    deadlineDate.setHours(closestDeadline.hour, closestDeadline.minute, 0, 0);
    
    if (deadlineDate.getTime() < now.getTime()) {
      deadlineDate.setDate(deadlineDate.getDate() + 7);
    }
    
    const timeDifference = deadlineDate.getTime() - now.getTime();
    return timeDifference >= requiredMsEarly;
  }
}

// ==================================================================
// H√ÄM PUBLIC - ƒê∆Ø·ª¢C G·ªåI T·ª™ FORM SCRIPT
// ==================================================================

/**
 * H√†m ch√≠nh x·ª≠ l√Ω khi c√≥ form submission
 * G·ªåI T·ª™ FORM: FormLib.onFormSubmit(e, recipientEmail)
 */
function onFormSubmit(e, recipientEmail) {
  try {
    const form = FormApp.getActiveForm();
    const formResponse = e.response;
    const now = new Date();
    
    const studentName = getResponseByTitle(formResponse, STUDENT_NAME_QUESTION_TITLE);
    if (!studentName) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y t√™n h·ªçc sinh. B·ªè qua.`);
      return;
    }
    
    let assignmentType = getResponseByTitle(formResponse, ASSIGNMENT_TYPE_QUESTION_TITLE);
    if (!assignmentType) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y lo·∫°i b√†i t·∫≠p cho "${studentName}". B·ªè qua.`);
      return;
    }
    
    const config = ConfigManager.findByName(assignmentType);
    if (!config) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y config cho "${assignmentType}". B·ªè qua.`);
      return;
    }
    
    if (config.isAttendance) {
      Logger.log(`B√†i t·∫≠p "${assignmentType}" l√† ƒêi·ªÉm danh, kh√¥ng x·ª≠ l√Ω n·ªôp b√†i.`);
      return;
    }
    
    const submissionStatus = ConfigManager.getSubmissionStatus(config, now, true);
    const isEarly = ConfigManager.isEarlySubmission(config, now);
    const isOverdue = (submissionStatus === "Overdue");
    
    Logger.log(`N·ªôp b√†i: ${studentName} | ${assignmentType} | Status: ${submissionStatus} | Early: ${isEarly}`);
    
    // X·ª≠ l√Ω file tr√™n Drive - S·ª¨A L·∫†I LOGIC
    if (!config.folderId) {
      Logger.log(`C·∫¢NH B√ÅO: Config "${assignmentType}" ch∆∞a c√≥ Folder ID. Kh√¥ng th·ªÉ l∆∞u file.`);
    } else {
      const targetParentFolder = DriveApp.getFolderById(config.folderId);
      const studentFolderName = isOverdue ? `[Qu√° h·∫°n] ${studentName}` : studentName;
      let studentFolder = findExistingStudentFolder(targetParentFolder, studentName);
      
      if (!studentFolder) {
        studentFolder = targetParentFolder.createFolder(studentFolderName);
        Logger.log(`T·∫°o th∆∞ m·ª•c m·ªõi: "${studentFolderName}"`);
      } else {
        Logger.log(`T√¨m th·∫•y th∆∞ m·ª•c: "${studentFolder.getName()}"`);
        
        if (isOverdue && !studentFolder.getName().toLowerCase().includes("qu√° h·∫°n")) {
          const oldName = studentFolder.getName();
          const newName = studentFolderName;
          studentFolder.setName(newName);
          Logger.log(`ƒê·ªïi t√™n th∆∞ m·ª•c: "${oldName}" ‚Üí "${newName}"`);
        }
      }
      
      // X·ª≠ l√Ω file upload - T√åM T·ª™ "File responses" FOLDER
      const fileResponses = formResponse.getItemResponses().filter(item => 
        item.getItem().getType() === FormApp.ItemType.FILE_UPLOAD
      );
      
      if (fileResponses.length > 0) {
        Logger.log(`T√¨m th·∫•y ${fileResponses.length} file upload items`);
        
        fileResponses.forEach(fileResponse => {
          const fileIds = fileResponse.getResponse();
          
          if (!fileIds || fileIds.length === 0) {
            Logger.log('Kh√¥ng c√≥ file IDs trong response');
            return;
          }
          
          Logger.log(`X·ª≠ l√Ω ${fileIds.length} files`);
          
          fileIds.forEach(fileId => {
            try {
              const file = DriveApp.getFileById(fileId);
              const fileName = file.getName();
              const fileSize = file.getSize();
              
              Logger.log(`X·ª≠ l√Ω file: "${fileName}" (${fileSize} bytes)`);
              
              // Ki·ªÉm tra file ƒë√£ t·ªìn t·∫°i trong folder h·ªçc sinh
              const existingFiles = studentFolder.getFilesByName(fileName);
              if (existingFiles.hasNext()) {
                const existingFile = existingFiles.next();
                const existingSize = existingFile.getSize();
                
                if (fileSize > existingSize) {
                  existingFile.setTrashed(true);
                  file.moveTo(studentFolder);
                  Logger.log(`Thay th·∫ø file c≈©: "${fileName}" (${existingSize} ‚Üí ${fileSize} bytes)`);
                } else if (fileSize === existingSize) {
                  file.setTrashed(true);
                  Logger.log(`File tr√πng: "${fileName}" (${fileSize} bytes). X√≥a b·∫£n m·ªõi.`);
                } else {
                  const newName = `${fileName.replace(/\.[^.]+$/, '')}_${Date.now()}${fileName.match(/\.[^.]+$/)[0]}`;
                  file.setName(newName);
                  file.moveTo(studentFolder);
                  Logger.log(`ƒê·ªïi t√™n file nh·ªè h∆°n: "${fileName}" ‚Üí "${newName}"`);
                }
              } else {
                // Move file t·ª´ "File responses" sang folder h·ªçc sinh
                file.moveTo(studentFolder);
                Logger.log(`‚úÖ Di chuy·ªÉn file: "${fileName}" v√†o "${studentFolder.getName()}"`);
              }
              
              // Convert DOCX sang PDF n·∫øu c·∫ßn
              if (/\.docx?$/i.test(fileName)) {
                convertFileToPdf(file, studentFolder);
              }
              
            } catch (fileErr) {
              Logger.log(`‚ùå L·ªói x·ª≠ l√Ω file ID ${fileId}: ${fileErr.message}`);
            }
          });
        });
      } else {
        Logger.log('Kh√¥ng c√≥ file upload trong form response');
      }
    }
    
    // C·∫≠p nh·∫≠t Google Sheet
    findAndMarkCheckbox(studentName, assignmentType, "onFormSubmit", isEarly, submissionStatus);
    
    // G·ª≠i email th√¥ng b√°o
    // ∆Øu ti√™n 1: Parameter t·ª´ wrapper
    // ∆Øu ti√™n 2: Script Properties
    // ∆Øu ti√™n 3: Sheet Config cell I6
    let emailRecipient = recipientEmail;
    
    if (!emailRecipient) {
      emailRecipient = PropertiesService.getScriptProperties().getProperty('RECIPIENT_EMAIL');
    }
    
    if (!emailRecipient) {
      // Th·ª≠ ƒë·ªçc t·ª´ Sheet Config cell I6
      try {
        const ss = getConfigSpreadsheet();
        if (ss) {
          const configSheet = ss.getSheetByName(CONFIG_SHEET_NAME);
          if (configSheet) {
            const emailFromSheet = configSheet.getRange('I6').getValue();
            if (emailFromSheet && typeof emailFromSheet === 'string' && emailFromSheet.includes('@')) {
              emailRecipient = emailFromSheet;
              Logger.log(`üìß L·∫•y email t·ª´ Sheet Config (I6): ${emailRecipient}`);
            }
          }
        }
      } catch (e) {
        Logger.log(`‚ö†Ô∏è Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c email t·ª´ Sheet: ${e.message}`);
      }
    }
    
    if (emailRecipient && emailRecipient !== "your_email@example.com") {
      try {
        const subject = `Bi·ªÉu m·∫´u: ${assignmentType}`;
        const body = `H·ªçc sinh "${studentName}" ƒë√£ n·ªôp b√†i "${assignmentType}".\nTr·∫°ng th√°i: ${submissionStatus}\nTh·ªùi gian: ${now.toLocaleString('vi-VN')}`;
        MailApp.sendEmail(emailRecipient, subject, body);
        Logger.log(`‚úÖ ƒê√£ g·ª≠i email th√¥ng b√°o ƒë·∫øn: ${emailRecipient}`);
      } catch (mailErr) {
        Logger.log(`‚ùå L·ªói g·ª≠i email: ${mailErr.message}`);
      }
    } else {
      Logger.log('‚ÑπÔ∏è Kh√¥ng g·ª≠i email: Ch∆∞a c·∫•u h√¨nh email th√¥ng b√°o');
      Logger.log('üí° H∆∞·ªõng d·∫´n: Ghi email v√†o Sheet "C·∫•u H√¨nh" cell I6');
    }
    
  } catch (err) {
    Logger.log(`L·ªói nghi√™m tr·ªçng trong onFormSubmit: ${err.message}`);
  }
}

/**
 * Web App handler ƒë·ªÉ s·ª≠a l·ªói t√™n
 * G·ªåI T·ª™ FORM: FormLib.doGet(e)
 */
function doGet(e) {
  Logger.log("ƒê√£ nh·∫≠n ƒë∆∞·ª£c y√™u c·∫ßu Web App (doGet)");
  let message = "ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.";
  
  try {
    const params = e.parameter;
    const action = params.action;
    const sheetTabId = params.sheetTabId;
    const formName = params.formName;
    
    if (!sheetTabId) {
      message = "L·ªñI: Y√™u c·∫ßu thi·∫øu sheetTabId.";
      Logger.log(message);
      return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
    }
    
    const lock = LockService.getScriptLock();
    lock.waitLock(10000);
    
    try {
      const ss = getConfigSpreadsheet();
      
      if (!ss) {
        message = 'L·ªñI: Kh√¥ng t√¨m th·∫•y Sheet. Vui l√≤ng ch·∫°y quickSetup().';
        Logger.log(message);
        return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
      }
      
      const sheet = getSheetByTabId(ss, sheetTabId);
      
      if (!sheet) {
        message = `L·ªñI: Kh√¥ng t√¨m th·∫•y sheet v·ªõi Tab ID: ${sheetTabId}`;
        Logger.log(message);
        return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
      }
      
      const sheetName = sheet.getName();
      
      if (action === "correct") {
        const suspectName = params.suspect;
        const correctName = params.correct;
        const checkboxCol = params.col;
        const rowNum = params.row;
        
        if (!suspectName || !correctName || !checkboxCol || !rowNum) {
          message = "L·ªñI: Thi·∫øu tham s·ªë (suspect, correct, col, row).";
          Logger.log(message);
          return HtmlService.createHtmlOutput(`<h2>L·ªói</h2><p>${message}</p>`);
        }
        
        const checkboxCell = sheet.getRange(`${checkboxCol}${rowNum}`);
        checkboxCell.setValue(true);
        
        const cache = PropertiesService.getScriptProperties();
        const cacheKey = `RECONCILE_EMAIL_SENT_${sheetName}_${correctName}`;
        cache.deleteProperty(cacheKey);
        
        message = `ƒê√£ s·ª≠a th√†nh c√¥ng: "${suspectName}" ‚Üí "${correctName}" v√† ƒë√°nh d·∫•u checkbox t·∫°i ${checkboxCol}${rowNum}.`;
        Logger.log(message);
        
      } else {
        message = `Action kh√¥ng h·ª£p l·ªá: "${action}". Ch·ªâ ch·∫•p nh·∫≠n 'correct'.`;
        Logger.log(message);
      }
      
    } catch (err) {
      message = `L·ªói khi c·∫≠p nh·∫≠t Sheet: ${err.message}`;
      Logger.log(message);
    } finally {
      lock.releaseLock();
    }
    
  } catch (err) {
    message = `L·ªói nghi√™m tr·ªçng trong doGet: ${err.message}`;
    Logger.log(message);
  }
  
  return HtmlService.createHtmlOutput(`
    <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; text-align: center; }
          h2 { color: #1a73e8; }
          p { color: #5f6368; }
        </style>
      </head>
      <body>
        <h2>K·∫øt qu·∫£</h2>
        <p>${message}</p>
      </body>
    </html>
  `);
}

/**
 * Ch·∫°y cleanup theo l·ªãch
 * G·ªåI T·ª™ FORM: FormLib.runScheduledCleanupAndEnsureOpen()
 */
function runScheduledCleanupAndEnsureOpen() {
  try {
    const form = FormApp.getActiveForm();
    
    if (!form.isAcceptingResponses()) {
      form.setAcceptingResponses(true);
      Logger.log('ƒê√£ m·ªü Form t·ª± ƒë·ªông.');
    }
    
    const configs = ConfigManager.loadAll();
    const now = new Date();
    const scriptProperties = PropertiesService.getScriptProperties();
    const todayKey = now.toLocaleDateString("vi-VN");
    
    for (const config of configs) {
      if (!config.autoCleanup) continue;
      
      for (const classTime of config.classTime) {
        const minutesUntilClass = getMinutesUntil(now, classTime);
        
        if (minutesUntilClass >= CLEANUP_WINDOW_MIN && minutesUntilClass <= CLEANUP_WINDOW_MAX) {
          const cleanupKey = `CLEANUP_${config.name}_${todayKey}`;
          
          if (scriptProperties.getProperty(cleanupKey)) {
            Logger.log(`ƒê√£ d·ªçn d·∫πp "${config.name}" h√¥m nay. B·ªè qua.`);
            continue;
          }
          
          Logger.log(`B·∫Øt ƒë·∫ßu d·ªçn d·∫πp "${config.name}" (${minutesUntilClass} ph√∫t tr∆∞·ªõc gi·ªù d·∫°y)`);
          
          if (config.sheetName) {
            cleanSheet(config.sheetName, "C:G");
          }
          
          if (!config.isAttendance) {
            if (config.formId) {
              cleanFormResponses(form, config.name);
            }
            cleanEmails(config.name);
          }
          
          scriptProperties.setProperty(cleanupKey, "done");
          Logger.log(`Ho√†n t·∫•t d·ªçn d·∫πp "${config.name}"`);
          break;
        }
      }
    }
    
  } catch (err) {
    Logger.log(`L·ªói trong runScheduledCleanupAndEnsureOpen: ${err.message}`);
  }
}

/**
 * Qu√©t v√† chuy·ªÉn ƒë·ªïi DOCX ƒë·ªãnh k·ª≥
 * G·ªåI T·ª™ FORM: FormLib.periodicCleanup()
 */
function periodicCleanup() {
  Logger.log("--- B·∫Øt ƒë·∫ßu qu√©t DOCX ƒë·ªãnh k·ª≥ ---");
  
  const configs = ConfigManager.loadAll();
  let totalConverted = 0;
  
  for (const config of configs) {
    if (config.isAttendance || !config.folderId) continue;
    
    try {
      const folder = DriveApp.getFolderById(config.folderId);
      totalConverted += scanAndConvertFolder(folder);
    } catch (err) {
      Logger.log(`L·ªói qu√©t folder "${config.name}": ${err.message}`);
    }
  }
  
  Logger.log(`--- Ho√†n t·∫•t qu√©t DOCX: ${totalConverted} files ---`);
}

/**
 * ƒê·ªìng b·ªô Folder IDs t·ª´ Sheet Config sang Script Properties
 * G·ªåI TH·ª¶ C√îNG 1 L·∫¶N sau khi ƒë√£ t·∫°o folders tr√™n web
 * HO·∫∂C t·ª± ƒë·ªông g·ªçi t·ª´ reconcileCheckboxes() n·∫øu ph√°t hi·ªán thi·∫øu folder IDs
 * 
 * @param {string} classFolderId - Class Folder ID (b·∫Øt bu·ªôc). L·∫•y t·ª´ cell I3 trong Sheet Config
 * @param {string} sheetId - (Optional) Sheet ID. N·∫øu kh√¥ng truy·ªÅn, s·∫Ω l·∫•y t·ª´ Script Properties
 */
function syncFolderIdsFromSheet(classFolderId, sheetId) {
  Logger.log("--- B·∫Øt ƒë·∫ßu ƒê·ªìng b·ªô Folder IDs ---");
  
  try {
    // Ki·ªÉm tra Class Folder ID (b·∫Øt bu·ªôc)
    if (!classFolderId) {
      Logger.log('‚ùå Thi·∫øu Class Folder ID.');
      Logger.log('üëâ H∆∞·ªõng d·∫´n: G·ªçi t·ª´ wrapper script v·ªõi CLASS_FOLDER_ID t·ª´ cell I3');
      Logger.log('   V√≠ d·ª•: FormLib.syncFolderIdsFromSheet(classFolderId)');
      return false;
    }
    
    // L·∫•y Sheet ID t·ª´ parameter ho·∫∑c Script Properties ho·∫∑c form destination
    const props = PropertiesService.getScriptProperties();
    if (!sheetId) {
      sheetId = props.getProperty('SHEET_ID');
    }
    
    if (!sheetId) {
      // Th·ª≠ l·∫•y t·ª´ form destination
      try {
        const form = FormApp.getActiveForm();
        sheetId = form.getDestinationId();
      } catch (e) {
        Logger.log('‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y Sheet ID t·ª´ form destination');
      }
    }
    
    if (!sheetId) {
      Logger.log('‚ùå Kh√¥ng t√¨m th·∫•y Sheet ID.');
      Logger.log('üëâ H√£y ch·∫°y "ƒê·ªìng b·ªô & Li√™n k·∫øt" tr√™n web app tr∆∞·ªõc.');
      return false;
    }
    
    Logger.log(`üìÑ Sheet ID: ${sheetId}`);
    Logger.log(`üìÇ Class Folder ID: ${classFolderId}`);
    
    const ss = SpreadsheetApp.openById(sheetId);
    const configSheet = ss.getSheetByName(CONFIG_SHEET_NAME);
    
    if (!configSheet) {
      Logger.log(`‚ùå Kh√¥ng t√¨m th·∫•y sheet "${CONFIG_SHEET_NAME}".`);
      return false;
    }
    
    // ƒê·ªçc danh s√°ch assignments t·ª´ Sheet Config (c·ªôt A)
    const lastRow = configSheet.getLastRow();
    const assignmentNames = configSheet.getRange(2, 1, Math.max(1, lastRow - 1), 1).getValues();
    
    // Qu√©t c√°c assignment folders trong class folder
    const classFolder = DriveApp.getFolderById(classFolderId);
    const subfolders = classFolder.getFolders();
    const folderMap = new Map();
    
    while (subfolders.hasNext()) {
      const subfolder = subfolders.next();
      const folderName = subfolder.getName();
      
      // B·ªè qua c√°c folder ƒë·∫∑c bi·ªát
      if (folderName.toLowerCase().includes('file responses') ||
          folderName.toLowerCase().includes('ƒëi·ªÉm danh')) {
        continue;
      }
      
      folderMap.set(folderName.toLowerCase().trim(), {
        id: subfolder.getId(),
        originalName: folderName
      });
    }
    
    Logger.log(`üìÅ T√¨m th·∫•y ${folderMap.size} folders tr√™n Drive`);
    
    // Match folders v·ªõi Sheet Config
    let savedCount = 0;
    for (let i = 0; i < assignmentNames.length; i++) {
      const assignmentName = assignmentNames[i][0];
      if (!assignmentName || typeof assignmentName !== 'string') continue;
      
      const nameTrimmed = assignmentName.toString().trim();
      if (!nameTrimmed) continue;
      
      // B·ªè qua "ƒêi·ªÉm danh"
      if (nameTrimmed === ATTENDANCE_SHEET_NAME) continue;
      
      // T√¨m folder kh·ªõp t√™n
      const folderInfo = folderMap.get(nameTrimmed.toLowerCase());
      
      if (folderInfo) {
        const key = `CONFIG_${nameTrimmed}_FOLDER_ID`;
        props.setProperty(key, folderInfo.id);
        Logger.log(`‚úÖ ƒê√£ l∆∞u: ${key} = ${folderInfo.id}`);
        savedCount++;
      } else {
        Logger.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y folder cho: "${nameTrimmed}"`);
      }
    }
    
    Logger.log(`\n‚ú® Ho√†n t·∫•t! ƒê√£ ƒë·ªìng b·ªô ${savedCount} folder IDs v√†o Script Properties.`);
    Logger.log(`üëâ B√¢y gi·ªù c√≥ th·ªÉ ch·∫°y reconcileCheckboxes() ƒë·ªÉ ƒë·ªëi so√°t.`);
    
    return savedCount > 0;
    
  } catch (err) {
    Logger.log(`‚ùå L·ªói ƒë·ªìng b·ªô: ${err.message}`);
    return false;
  }
}

// ==================================================================
// H√ÄM INTERNAL - KH√îNG G·ªåI TR·ª∞C TI·∫æP T·ª™ B√äN NGO√ÄI
// ==================================================================

function findAndMarkCheckbox(originalName, assignmentType, context, isEarly, submissionStatus) {
  if (!originalName) return null;
  
  try {
    const config = ConfigManager.findByName(assignmentType);
    if (!config || config.isAttendance) {
      Logger.log(`Config kh√¥ng h·ª£p l·ªá ho·∫∑c l√† ƒêi·ªÉm danh. B·ªè qua.`);
      return null;
    }
    
    const ss = getConfigSpreadsheet();
    if (!ss) {
      Logger.log('L·ªói: Kh√¥ng t√¨m th·∫•y Sheet. Kh√¥ng th·ªÉ ƒë√°nh d·∫•u checkbox.');
      return null;
    }
    let sheet;
    
    if (config.sheetTabId) {
      sheet = getSheetByTabId(ss, config.sheetTabId);
    } else {
      sheet = ss.getSheetByName(config.sheetName);
    }
    
    if (!sheet) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y sheet "${config.sheetName}"`);
      return null;
    }
    
    let advantageColumnLetter = null;
    if (isEarly && context === 'onFormSubmit') {
      advantageColumnLetter = findAndCacheAdvantageColumn(sheet, config.sheetTabId || sheet.getSheetId());
    }
    
    const nameColumnValues = sheet.getRange(`${SHEET_COL.NAME}1:${SHEET_COL.NAME}${sheet.getLastRow()}`).getValues();
    const checkboxValues = sheet.getRange(`${SHEET_COL.CHECKBOX}1:${SHEET_COL.CHECKBOX}${sheet.getLastRow()}`).getValues();
    
    const mapList = [];
    for (let i = 0; i < nameColumnValues.length; i++) {
      const cellValue = nameColumnValues[i][0];
      const isChecked = checkboxValues[i][0];
      
      if (!cellValue || typeof cellValue !== 'string') continue;
      if (cellValue.toLowerCase().includes('t√™n') || cellValue.toLowerCase().includes('name')) continue;
      
      const originalLC = cellValue.toLowerCase().trim();
      const normalized = normalizeString(cellValue);
      const words = normalized.split(/\s+/).filter(Boolean);
      const lastTwo = words.length >= 2 ? words.slice(-2).join(' ') : normalized;
      
      mapList.push({
        original: cellValue,
        originalLC: originalLC,
        normalized: normalized,
        lastTwo: lastTwo,
        row: i + 1,
        isChecked: isChecked
      });
    }
    
    if (mapList.length === 0) {
      Logger.log('Sheet kh√¥ng c√≥ d·ªØ li·ªáu h·ªçc sinh');
      return null;
    }
    
    const nameFromForm = originalName.toLowerCase().trim();
    const normalizedNameFromForm = normalizeString(originalName);
    const wordsFromForm = normalizedNameFromForm.split(/\s+/).filter(Boolean);
    const lastTwoFromForm = wordsFromForm.length >= 2 ? wordsFromForm.slice(-2).join(' ') : normalizedNameFromForm;
    
    let bestMatch = null;
    let matchLevel = null;
    
    // Phase 1: Exact match
    bestMatch = mapList.find(item => item.originalLC === nameFromForm);
    if (bestMatch) matchLevel = "Phase 1 - Exact";
    
    // Phase 2: Last two words (c√≥ d·∫•u) - So s√°nh v·ªõi t√™n g·ªëc ƒë√£ lowercase
    // "Con Minh To√†n" -> l·∫•y 2 t·ª´ cu·ªëi t·ª´ nameFromForm: "minh to√†n"
    if (!bestMatch && nameFromForm.split(/\s+/).length >= 2) {
      const formWordsLC = nameFromForm.split(/\s+/).filter(Boolean);
      const formLastTwoLC = formWordsLC.slice(-2).join(' ');
      
      bestMatch = mapList.find(item => {
        const itemWords = item.originalLC.split(/\s+/).filter(Boolean);
        if (itemWords.length < 2) return false;
        const itemLastTwo = itemWords.slice(-2).join(' ');
        return itemLastTwo === formLastTwoLC;
      });
      if (bestMatch) matchLevel = "Phase 2 - Last2 (d·∫•u)";
    }
    
    // Phase 3: Last two words (kh√¥ng d·∫•u) - So s√°nh sau khi chu·∫©n h√≥a
    // "Con Minh Toan" -> normalize -> "minh toan"
    if (!bestMatch && wordsFromForm.length >= 2) {
      bestMatch = mapList.find(item => {
        if (!item.lastTwo || item.lastTwo.length < 4) return false;
        return item.lastTwo === lastTwoFromForm;
      });
      if (bestMatch) matchLevel = "Phase 3 - Last2 (normalized)";
    }
    
    if (bestMatch) {
      Logger.log(`${matchLevel}: "${originalName}" ‚Üí "${bestMatch.original}"`);
      
      const checkboxCell = sheet.getRange(`${SHEET_COL.CHECKBOX}${bestMatch.row}`);
      const noteCell = sheet.getRange(`${SHEET_COL.NOTE}${bestMatch.row}`);
      
      if (submissionStatus === "OnTime") {
        checkboxCell.setValue(true);
        if (isEarly && advantageColumnLetter) {
          addEarlyComment(sheet, advantageColumnLetter, bestMatch.row);
        }
      } else if (submissionStatus === "LateGrace") {
        checkboxCell.setValue(true);
        const currentNote = noteCell.getValue().toString();
        if (!currentNote.includes(LATE_SUBMISSION_COMMENT)) {
          const newNote = currentNote ? `${currentNote}\n${LATE_SUBMISSION_COMMENT}` : LATE_SUBMISSION_COMMENT;
          noteCell.setValue(newNote);
        }
      } else {
        const currentNote = noteCell.getValue().toString();
        if (!currentNote.includes(LATE_SUBMISSION_COMMENT)) {
          const newNote = currentNote ? `${currentNote}\n${LATE_SUBMISSION_COMMENT}` : LATE_SUBMISSION_COMMENT;
          noteCell.setValue(newNote);
        }
      }
      
      return bestMatch.original;
    }
    
    // Phase 4: Typo detection
    let typoTargetMapList = mapList;
    if (context === 'onFormSubmit') {
      typoTargetMapList = mapList.filter(item => item.isChecked !== true);
    }
    
    let typoCandidates = [];
    for (const item of typoTargetMapList) {
      const distance = levenshteinDistance(normalizedNameFromForm, item.normalized);
      if (distance > 0 && distance <= TYPO_THRESHOLD) {
        typoCandidates.push({
          original: item.original,
          normalized: item.normalized,
          row: item.row,
          distance: distance
        });
      }
    }
    
    typoCandidates.sort((a, b) => a.distance - b.distance);
    
    if (typoCandidates.length > 0) {
      const bestGuess = typoCandidates[0];
      const otherCandidates = typoCandidates.slice(1, 4);
      
      Logger.log(`Phase 4 - Typo: "${originalName}" ‚Üí ƒêo√°n "${bestGuess.original}" (distance: ${bestGuess.distance})`);
      
      const checkboxCell = sheet.getRange(`${SHEET_COL.CHECKBOX}${bestGuess.row}`);
      checkboxCell.setValue(true);
      
      if (context === 'onFormSubmit') {
        sendCorrectionEmail(
          originalName,
          config.sheetName,
          config.sheetTabId || sheet.getSheetId(),
          SHEET_COL.CHECKBOX,
          bestGuess,
          otherCandidates
        );
      }
      
      return bestGuess.original;
    }
    
    Logger.log(`Kh√¥ng t√¨m th·∫•y kh·ªõp cho "${originalName}"`);
    return null;
    
  } catch (err) {
    Logger.log(`L·ªói trong findAndMarkCheckbox: ${err.message}`);
    return null;
  }
}

function getMinutesUntil(now, classTime) {
  const target = new Date(now.getTime());
  
  const dayDiff = (classTime.day - now.getDay() + 7) % 7;
  target.setDate(target.getDate() + dayDiff);
  target.setHours(classTime.hour, classTime.minute, 0, 0);
  
  if (target.getTime() < now.getTime()) {
    target.setDate(target.getDate() + 7);
  }
  
  const diffMs = target.getTime() - now.getTime();
  return Math.floor(diffMs / 60000);
}

function cleanSheet(sheetName, columnRange) {
  try {
    const ss = getConfigSpreadsheet();
    
    if (!ss) {
      Logger.log('C·∫£nh b√°o: Kh√¥ng t√¨m th·∫•y Sheet. B·ªè qua clean sheet.');
      return;
    }
    
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      Logger.log(`Kh√¥ng t√¨m th·∫•y sheet "${sheetName}"`);
      return;
    }
    
    const range = sheet.getRange(`${columnRange}2:${columnRange}`);
    range.clearContent();
    Logger.log(`ƒê√£ d·ªçn d·∫πp sheet "${sheetName}" (c·ªôt ${columnRange})`);
    
  } catch (err) {
    Logger.log(`L·ªói d·ªçn d·∫πp sheet "${sheetName}": ${err.message}`);
  }
}

function cleanFormResponses(form, assignmentType) {
  try {
    Logger.log(`B·∫Øt ƒë·∫ßu x√≥a c√¢u tr·∫£ l·ªùi Form cho "${assignmentType}"`);
    let deleteCount = 0;
    
    const responses = form.getResponses();
    const items = form.getItems();
    let assignmentQuestionItemId = null;
    
    for (const item of items) {
      if (item.getTitle() === ASSIGNMENT_TYPE_QUESTION_TITLE) {
        assignmentQuestionItemId = item.getId();
        break;
      }
    }
    
    if (!assignmentQuestionItemId) {
      Logger.log('Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi lo·∫°i b√†i t·∫≠p trong Form');
      return;
    }
    
    for (const response of responses) {
      const itemResponses = response.getItemResponses();
      
      for (const itemResponse of itemResponses) {
        if (itemResponse.getItem().getId() === assignmentQuestionItemId) {
          const answer = itemResponse.getResponse();
          
          if (answer === assignmentType) {
            form.deleteResponse(response.getId());
            deleteCount++;
            break;
          }
        }
      }
    }
    
    Logger.log(`ƒê√£ x√≥a ${deleteCount} c√¢u tr·∫£ l·ªùi cho "${assignmentType}"`);
    
  } catch (err) {
    Logger.log(`L·ªói x√≥a Form responses: ${err.message}`);
  }
}

function cleanEmails(assignmentType) {
  try {
    const searchQuery = `subject:"Bi·ªÉu m·∫´u: ${assignmentType}" in:inbox is:read`;
    const threads = GmailApp.search(searchQuery);
    
    if (threads.length > 0) {
      GmailApp.moveThreadsToTrash(threads);
      Logger.log(`ƒê√£ x√≥a ${threads.length} email cho "${assignmentType}"`);
    }
    
  } catch (err) {
    Logger.log(`L·ªói x√≥a email: ${err.message}`);
  }
}

function findExistingStudentFolder(parentFolder, studentName) {
  try {
    const studentNameNormalized = normalizeString(studentName);
    const studentNameWords = studentNameNormalized.split(/\s+/).filter(Boolean);
    const allSubfolders = parentFolder.getFolders();
    const foundFolders = [];
    
    while (allSubfolders.hasNext()) {
      const subfolder = allSubfolders.next();
      const subfolderName = subfolder.getName();
      const subfolderNormalized = normalizeString(subfolderName);
      const subfolderWords = subfolderNormalized.split(/\s+/).filter(Boolean);
      
      const matchA = studentNameWords.every(w => subfolderNormalized.includes(w));
      const matchB = subfolderWords.every(w => studentNameNormalized.includes(w));
      
      if (matchA || matchB) {
        foundFolders.push(subfolder);
      }
    }
    
    if (foundFolders.length === 1) {
      return foundFolders[0];
    } else if (foundFolders.length > 1) {
      Logger.log(`T√¨m th·∫•y nhi·ªÅu th∆∞ m·ª•c cho "${studentName}". C·∫ßn ki·ªÉm tra.`);
      return null;
    }
    
    return null;
    
  } catch (err) {
    Logger.log(`L·ªói t√¨m th∆∞ m·ª•c: ${err.message}`);
    return null;
  }
}

function scanAndConvertFolder(parentFolder) {
  if (!parentFolder) return 0;
  
  let filesConverted = 0;
  const subfolders = parentFolder.getFolders();
  
  while (subfolders.hasNext()) {
    const subfolder = subfolders.next();
    const files = subfolder.getFilesByType(MimeType.MICROSOFT_WORD);
    
    while (files.hasNext()) {
      const file = files.next();
      convertFileToPdf(file, subfolder);
      filesConverted++;
    }
    
    const docxFiles = subfolder.getFiles();
    while (docxFiles.hasNext()) {
      const file = docxFiles.next();
      if (/\.docx?$/i.test(file.getName())) {
        convertFileToPdf(file, subfolder);
        filesConverted++;
      }
    }
  }
  
  return filesConverted;
}

function convertFileToPdf(file, targetFolder) {
  const fileName = file.getName();
  
  try {
    if (file.isTrashed()) return;
    
    const pdfName = fileName.replace(/\.docx?$/i, '.pdf');
    const existingPdfs = targetFolder.getFilesByName(pdfName);
    
    if (existingPdfs.hasNext()) {
      Logger.log(`PDF ƒë√£ t·ªìn t·∫°i: "${pdfName}"`);
      return;
    }
    
    Logger.log(`Chuy·ªÉn ƒë·ªïi: "${fileName}"`);
    
    let pdfBlob;
    try {
      const docBlob = file.getBlob();
      pdfBlob = docBlob.getAs('application/pdf');
    } catch (conversionErr) {
      Logger.log(`L·ªói chuy·ªÉn ƒë·ªïi "${fileName}": ${conversionErr.message}`);
      try {
        file.moveTo(targetFolder);
      } catch (e) {}
      return;
    }
    
    const pdfFile = targetFolder.createFile(pdfBlob).setName(pdfName);
    Logger.log(`ƒê√£ chuy·ªÉn ƒë·ªïi: "${fileName}" ‚Üí "${pdfName}"`);
    file.setTrashed(true);
    
  } catch (generalErr) {
    Logger.log(`L·ªói v·ªõi "${fileName}": ${generalErr.message}`);
    try {
      file.moveTo(targetFolder);
    } catch (e) {}
  }
}

function getResponseByTitle(formResponse, title) {
  const itemResponses = formResponse.getItemResponses();
  for (const itemResponse of itemResponses) {
    if (itemResponse.getItem().getTitle() === title) {
      return itemResponse.getResponse();
    }
  }
  return null;
}

function sendCorrectionEmail(suspectName, sheetName, sheetTabId, checkboxCol, bestGuess, otherCandidates) {
  const recipientEmail = PropertiesService.getScriptProperties().getProperty('RECIPIENT_EMAIL');
  if (!recipientEmail) return;
  
  try {
    const webAppUrl = ScriptApp.getService().getUrl();
    if (!webAppUrl) {
      Logger.log('Ch∆∞a deploy Web App. Kh√¥ng th·ªÉ g·ª≠i email s·ª≠a l·ªói.');
      return;
    }
    
    let buttonsHtml = "";
    otherCandidates.forEach(candidate => {
      const url = `${webAppUrl}?action=correct&suspect=${encodeURIComponent(suspectName)}&correct=${encodeURIComponent(candidate.original)}&sheetTabId=${sheetTabId}&col=${checkboxCol}&row=${candidate.row}`;
      buttonsHtml += `
        <a href="${url}" style="display:inline-block;margin:5px;padding:10px 15px;background:#f1f3f4;color:#5f6368;text-decoration:none;border-radius:8px;font-weight:500;">
          ${candidate.original} (kho·∫£ng c√°ch: ${candidate.distance})
        </a>
      `;
    });
    
    const subject = `[C·∫¢NH B√ÅO] ƒê√£ t·ª± ƒë·ªông ƒëo√°n t√™n: "${suspectName}"`;
    const bodyHtml = `
      <div style="font-family:Arial,sans-serif;max-width:600px;margin:auto;padding:20px;border:1px solid #dadce0;border-radius:8px;">
        <h2 style="color:#d93025;">Ph√°t hi·ªán t√™n c√≥ th·ªÉ sai</h2>
        <p>H·ªá th·ªëng ƒë√£ t·ª± ƒë·ªông ƒëo√°n t√™n n·ªôp b√†i <strong>"${suspectName}"</strong> l√†:</p>
        <div style="background:#e8f0fe;padding:15px;border-radius:8px;margin:15px 0;">
          <strong style="color:#1967d2;font-size:18px;">${bestGuess.original}</strong>
          <br><span style="color:#5f6368;">(Kho·∫£ng c√°ch: ${bestGuess.distance})</span>
        </div>
        <p>N·∫øu sai, click v√†o t√™n ƒë√∫ng b√™n d∆∞·ªõi ƒë·ªÉ s·ª≠a:</p>
        <div style="margin:20px 0;">${buttonsHtml}</div>
        <p style="font-size:12px;color:#5f6368;margin-top:20px;">Checkbox ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông ƒë√°nh d·∫•u cho "${bestGuess.original}".</p>
      </div>
    `;
    
    MailApp.sendEmail({
      to: recipientEmail,
      subject: subject,
      htmlBody: bodyHtml
    });
    
    Logger.log(`ƒê√£ g·ª≠i email s·ª≠a l·ªói cho "${suspectName}"`);
    
  } catch (e) {
    Logger.log(`L·ªói g·ª≠i email: ${e.message}`);
  }
}

function normalizeString(str) {
  if (!str || typeof str !== 'string') return "";
  
  const prefixRegex = new RegExp(`^(${PREFIX_KEYWORDS_TO_REMOVE.join("|")})\\s+`, 'g');
  
  return str.toLowerCase()
    .trim()
    .replace(prefixRegex, "")
    .replace(/[\(\[\{].*?[\)\]\}]/g, "")
    .replace(/[-_,\/\\|]/g, ' ')
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/ƒë/g, 'd')
    .replace(/\s+/g, ' ')
    .trim();
}

function levenshteinDistance(s1, s2) {
  s1 = s1 || "";
  s2 = s2 || "";
  const m = s1.length;
  const n = s2.length;
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));
  
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (s1[i - 1] === s2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
      }
    }
  }
  
  return dp[m][n];
}

function getSheetByTabId(spreadsheet, id) {
  if (!spreadsheet || id == null) return null;
  
  const sheets = spreadsheet.getSheets();
  for (const sheet of sheets) {
    if (sheet.getSheetId() == id) {
      return sheet;
    }
  }
  return null;
}

function addEarlyComment(sheet, col, row) {
  try {
    if (!col || !row) return;
    
    const cellAddress = `${col}${row}`;
    const cell = sheet.getRange(cellAddress);
    const currentComment = cell.getValue().toString();
    
    if (currentComment.includes(EARLY_SUBMISSION_COMMENT)) {
      return;
    }
    
    const newComment = currentComment ? 
      `${currentComment}\n${EARLY_SUBMISSION_COMMENT}` : 
      EARLY_SUBMISSION_COMMENT;
    
    cell.setValue(newComment);
    Logger.log(`ƒê√£ th√™m nh·∫≠n x√©t n·ªôp s·ªõm t·∫°i ${cellAddress}`);
    
  } catch (err) {
    Logger.log(`L·ªói th√™m nh·∫≠n x√©t: ${err.message}`);
  }
}

function findAndCacheAdvantageColumn(sheet, sheetTabId) {
  const cache = PropertiesService.getScriptProperties();
  const cacheKey = `ADV_COL_GID_${sheetTabId}`;
  
  const cachedCol = cache.getProperty(cacheKey);
  if (cachedCol) {
    return (cachedCol === "NONE") ? null : cachedCol;
  }
  
  try {
    const headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    let foundColLetter = null;
    
    for (let i = 0; i < headerRow.length; i++) {
      const cellValue = headerRow[i].toString().toLowerCase();
      
      for (const keyword of ADVANTAGE_KEYWORDS) {
        if (cellValue.includes(keyword)) {
          foundColLetter = colIndexToLetter(i + 1);
          break;
        }
      }
      
      if (foundColLetter) break;
    }
    
    if (foundColLetter) {
      cache.setProperty(cacheKey, foundColLetter);
      Logger.log(`T√¨m th·∫•y c·ªôt ∆Øu ƒëi·ªÉm: ${foundColLetter}`);
      return foundColLetter;
    } else {
      cache.setProperty(cacheKey, "NONE");
      Logger.log('Kh√¥ng t√¨m th·∫•y c·ªôt ∆Øu ƒëi·ªÉm');
      return null;
    }
    
  } catch (err) {
    Logger.log(`L·ªói t√¨m c·ªôt ∆Øu ƒëi·ªÉm: ${err.message}`);
    return null;
  }
}

function colIndexToLetter(colIndex) {
  let temp, letter = '';
  while (colIndex > 0) {
    temp = (colIndex - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    colIndex = (colIndex - temp - 1) / 26;
  }
  return letter;
}
