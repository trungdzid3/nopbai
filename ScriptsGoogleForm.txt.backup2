/**
 * Tệp Apps Script này thực hiện các nhiệm vụ tự động cho Google Form.
 * PHIÊN BẢN 24.8 (Đồng bộ Lịch dọn dẹp)
 *
 * - (MỚI V24.8) Đồng bộ lịch dọn dẹp. "Khác" (OTH) sẽ dọn dẹp cùng "Đại số" (THU) lúc 18:00 T5 và cùng "Hình học" (SUN) lúc 17:00 CN.
 * - (V24.7) Giữ nguyên hạn nộp Khác (OTH_A) là 23:00 Thứ 3.
 * - (V24.5) Giữ nguyên hạn nộp Đại số (THU) là 23:00 Thứ 3.
 */

// ==================================================================
// PHẦN CẤU HÌNH (BẮT BUỘC)
// ==================================================================

// 1. (*** Giữ nguyên V10 ***) Cấu hình Google Drive (Dùng ID)
const PARENT_FOLDER_THU_ID = "1IySQLWKcMaIQZ6XmOvDJf9OeDTmQYiRD";
const PARENT_FOLDER_SUN_ID = "1-kmfNyUA-iSANbFRSaW5TUiT8kciDd-a";
const PARENT_FOLDER_OTH_ID = "1F_h6sa-I6wmf-3KVrJ49Kg6KJZyJM-Vu";

// 2. (*** Giữ nguyên V10 ***) Cấu hình Câu hỏi Form
const STUDENT_NAME_QUESTION_TITLE = "Tên học sinh (chỉ điền tên đệm và tên):";
const ASSIGNMENT_TYPE_QUESTION_TITLE = "Chọn bài tập:";
const ASSIGNMENT_TYPE_THU = "Bài tập thứ 5";
const ASSIGNMENT_TYPE_SUN = "Bài tập Chủ nhật";
const ASSIGNMENT_TYPE_OTH = "Khác";


// 3. (*** CẬP NHẬT V14.3 ***) Cấu hình 3 Sheet (Dùng ID trang tính - GID)
const SHEET_ID = "1GiQWCCgl9XAJ6DqTiSjRZkzPztaT6nEix3qyZmCOHV8"; // ID Của FILE

// (*** MỚI V14 ***) Cập nhật GID (ID trang tính)
const SHEET_TAB_ID_THU = "1234172792"; // <<< GID (ID TRANG TÍNH) CỦA SHEET ĐẠI SỐ
const SHEET_TAB_ID_SUN = "566805598"; // <<< GID (ID TRANG TÍNH) CỦA SHEET HÌNH HỌC
const SHEET_TAB_ID_OTH = "125828814"; // <<< GID (ID TRANG TÍNH) CỦA SHEET KHÁC

// Cấu hình cho Sheet (Trang) BÀI TẬP THỨ 5
const SHEET_NAME_THU = "Bảng nhận xét (Đại số)";
const NAME_COLUMN_THU = "B";
const CHECKBOX_COLUMN_THU = "G";

// Cấu hình cho Sheet (Trang) BÀI TẬP CHỦ NHẬT
const SHEET_NAME_SUN = "Bảng nhận xét (Hình học)";
const NAME_COLUMN_SUN = "B";
const CHECKBOX_COLUMN_SUN = "G";

// Cấu hình cho Sheet (Trang) BÀI TẬP KHÁC
const SHEET_NAME_OTH = "Bảng nhận xét (Khác)";
const NAME_COLUMN_OTH = "B";
const CHECKBOX_COLUMN_OTH = "G";


// 4. (*** Giữ nguyên V10 ***) Cấu hình Email thông báo
const RECIPIENT_EMAIL = "trungdzid3@gmail.com";
const SUBJECT_TEMPLATE_THU = "Biểu mẫu: Bài tập Thứ 5";
const SUBJECT_TEMPLATE_SUN = "Biểu mẫu: Bài tập Chủ Nhật";
const SUBJECT_TEMPLATE_OTH = "Biểu mẫu: Bài tập Khác";

// 5. (*** CẬP NHẬT V24.7 ***) Cấu hình lịch nộp bài
const TIME_OPEN_THU_NUM = (5 * 10000) + (0 * 100) + 0; // 50000 (Thứ 6 00:00)
const TIME_CLOSE_THU_NUM = (2 * 10000) + (23 * 100) + 0; // 22300 (Thứ 3 23:00) (V24.5)

const TIME_OPEN_SUN_NUM = (1 * 10000) + (12 * 100) + 0; // 11200 (Thứ 2 12:00)
const TIME_CLOSE_SUN_NUM = (6 * 10000) + (22 * 100) + 0; // 62200 (Thứ 7 22:00)

const TIME_OPEN_OTH_NUM_A = (1 * 10000) + (12 * 100) + 0; // 11200 (Thứ 2 12:00)
const TIME_CLOSE_OTH_NUM_A = (2 * 10000) + (23 * 100) + 0; // 22300 (Thứ 3 23:00) (V24.7)

const TIME_OPEN_OTH_NUM_B = (5 * 10000) + (0 * 100) + 0; // 50000 (Thứ 6 00:00)
const TIME_CLOSE_OTH_NUM_B = (6 * 10000) + (22 * 100) + 0; // 62200 (Thứ 7 22:00)

// 6. (MỚI V14.1) Cấu hình Du di
const GRACE_PERIOD_MINUTES = 10; // <<< SỐ PHÚT DU DI (10 PHÚT)

// 7. (CẬP NHẬT V14.3) Cấu hình Lời khen nộp sớm
const EARLY_SUBMISSION_COMMENT = "Làm bài tập về nhà chăm chỉ, tinh thần học tập tốt, làm và nộp BTVN từ sớm.";

// 7.1 (CẬP NHẬT V14.3+) TỪ KHÓA ĐỂ TÌM CỘT ƯU ĐIỂM (Đã mở rộng)
const ADVANTAGE_KEYWORDS = [
  "ưu điểm", "ưu", "tốt", "giỏi", "khen", "nhận xét", // Từ khóa gốc
  "tích cực", "phê", "thưởng", "cộng" // Từ khóa mới (đã bỏ "đánh giá", "lời phê")
];

// 7.2 (MỚI V20) Cấu hình ngưỡng Typo
const TYPO_THRESHOLD = 2; // CHỈ cho phép sai 1 hoặc 2 ký tự

// 7.3 (MỚI V21) Tiền tố (Prefix) cần loại bỏ khi chuẩn hóa
const PREFIX_KEYWORDS_TO_REMOVE = ["con", "em", "bạn", "cháu", "hs", "hoc sinh"];


// ==================================================================
// KẾT THÚC CẤU HÌNH
// ==================================================================


/**
 * HÀM WEB APP V14 (Giữ nguyên)
 * (*** CẬP NHẬT V20: Thêm xóa cache khi sửa lỗi ***)
 */
function doGet(e) {
  Logger.log("Đã nhận được yêu cầu Web App (doGet)");
  let message = "Đã xảy ra lỗi. Vui lòng thử lại.";
  
  try {
    const params = e.parameter;
    const action = params.action;
    const sheetTabId = params.sheetTabId; 
    const formName = params.formName;
    
    if (!sheetTabId) {
        message = "LỖI: Yêu cầu thiếu sheetTabId.";
        Logger.log(message);
        return HtmlService.createHtmlOutput(`<h2>Lỗi</h2><p>${message}</p>`);
    }

    const lock = LockService.getScriptLock();
    lock.waitLock(10000); 
      
    try {
      let spreadSheet;
      try {
        spreadSheet = SpreadsheetApp.openById(SHEET_ID);
      } catch (openErr) {
        Logger.log(`LỖI NGHIÊM TRỌNG (doGet): Không thể mở Sheet ID. Lỗi: ${openErr.message}`);
        message = `LỖI: Không thể mở Google Sheet. Dịch vụ Google có thể đang tạm thời gián đoạn.`;
        lock.releaseLock();
        return HtmlService.createHtmlOutput(`<h2>Lỗi</h2><p>${message}</p>`);
      }
      
      const sheet = getSheetByTabId(spreadSheet, sheetTabId); 
      
      if (!sheet) {
          message = `LỖI: Không tìm thấy trang tính với GID "${sheetTabId}".`;
          Logger.log(message);
          lock.releaseLock();
          return HtmlService.createHtmlOutput(`<h2>Lỗi</h2><p>${message}</p>`);
      }
      const sheetName = sheet.getName(); 

      // --- Logic MỚI V13: Sửa lỗi (action=correct) ---
      if (action === "correct") {
        const oldRow = params.oldRow;
        const oldCol = params.oldCol;
        const newRow = params.newRow;
        const newCol = params.newCol;
        
        if (oldRow && oldCol && newRow && newCol) {
          const oldCell = sheet.getRange(`${oldCol}${oldRow}`);
          oldCell.setValue(false); 
          
          const newCell = sheet.getRange(`${newCol}${newRow}`);
          newCell.setValue(true); 
          
          // (*** CẬP NHẬT V20 ***)
          // Nếu đây là hành động sửa lỗi, chúng ta cần xóa cờ "đã gửi mail"
          // để nếu reconcile chạy lại, nó có thể gửi mail tiếp nếu cần.
          const scriptProperties = PropertiesService.getScriptProperties();
          const cacheKeyOld = `reconcile_email_${sheetTabId}_${oldRow}`;
          const cacheKeyNew = `reconcile_email_${sheetTabId}_${newRow}`;
          scriptProperties.deleteProperty(cacheKeyOld);
          scriptProperties.deleteProperty(cacheKeyNew);

          message = `XÁC NHẬN SỬA LỖI: Đã BỎ đánh dấu ô ${oldCol}${oldRow} và ĐÁNH DẤU ô ${newCol}${newRow} cho "${formName}" (Sheet: ${sheetName}). Đã xóa cờ cache.`;
          Logger.log(message);
        } else {
          message = "LỖI (Sửa lỗi): Thiếu tham số (oldRow, oldCol, newRow, newCol).";
          Logger.log(message);
        }

      // --- Logic Cũ V12: Đánh dấu (action=mark) ---
      } else if (action === "mark") {
        // (Hàm này hiện không dùng, nhưng giữ lại để dự phòng)
        const row = params.row;
        const col = params.col;

        if (row && col) {
          const cell = sheet.getRange(`${col}${row}`);
          if (cell.getValue() !== true) {
            cell.setValue(true);
            message = `XÁC NHẬN: Đã đánh dấu checkbox cho "${formName}" tại ô ${col}${row} (Sheet: ${sheetName}).`;
            Logger.log(message);
          } else {
            message = `THÔNG BÁO: Checkbox tại ô ${col}${row} (Sheet: ${sheetName}) đã được đánh dấu từ trước.`;
          }
        } else {
          message = "LỖI (Đánh dấu): Thiếu tham số (row, col).";
          Logger.log(message);
        }
      } else {
        message = "LỖI: Hành động không được hỗ trợ. Chỉ hỗ trợ 'action=mark' hoặc 'action=correct'.";
        Logger.log(message);
      }

    } catch (err) {
      message = `Lỗi khi cập nhật Sheet: ${err.message}`;
      Logger.log(message);
    } finally {
      lock.releaseLock();
    }
  } catch (err)
 {
    message = `Lỗi nghiêm trọng trong doGet: ${err.message}`;
    Logger.log(message);
  }
  
  // Trả về trang HTML thông báo cho người dùng
  return HtmlService.createHtmlOutput(
    `<html>
      <head>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .container { padding: 20px; border: 1px solid #ccc; border-radius: 8px; background-color: #f9f9f9; }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Thông báo từ Hệ thống Tự động</h2>
          <p>${message}</p>
          <p>Bạn có thể đóng tab này.</p>
        </div>
      </body>
    </html>`
  );
}


/**
 * HÀM 1: Chạy tự động khi có người nộp biểu mẫu.
 * (Giữ nguyên V23)
 */
function onFormSubmit(e) {
  try {
    // === Phần 1: Lấy thông tin cơ bản ===
    const form = FormApp.getActiveForm();
    const formResponse = e.response;
    const now = new Date(); // Thời gian nộp BÀI GỐC
    
    // (*** V14.1 : LOGIC DU DI ***)
    const adjustedTime = new Date(now.getTime() - GRACE_PERIOD_MINUTES * 60000);
    const day = adjustedTime.getDay();
    const hour = adjustedTime.getHours();
    const minute = adjustedTime.getMinutes();
    const currentTimeNum = (day * 10000) + (hour * 100) + minute; // Dùng để tính "isOverdue"

    // (*** MỚI V14.2: Dùng thời gian GỐC để tính "isEarly" ***)
    const realDay = now.getDay();
    const realHour = now.getHours();
    const realMinute = now.getMinutes();
    const realTimeNum = (realDay * 10000) + (realHour * 100) + realMinute;

    // Lấy tên học sinh
    const studentName = getResponseByTitle(formResponse, STUDENT_NAME_QUESTION_TITLE);
    if (!studentName) {
      Logger.log(`Không tìm thấy câu trả lời cho câu hỏi: "${STUDENT_NAME_QUESTION_TITLE}". Đang thoát.`);
      return;
    }
    
    // Lấy loại bài tập
    let assignmentType = getResponseByTitle(formResponse, ASSIGNMENT_TYPE_QUESTION_TITLE);
    if (!assignmentType) {
        Logger.log(`Không tìm thấy câu trả lời cho câu hỏi: "${ASSIGNMENT_TYPE_QUESTION_TITLE}". Sẽ xử lý như bài tập Khác (mặc định) và Quá hạn.`);
    }

    // === Phần 2: Xác định thư mục đích, trạng thái, và nộp sớm ===
    let targetParentFolder;
    let isOverdue = false;
    let emailSubjectBase;
    let isEarly = false; // (*** MỚI V14.2 ***)

    if (assignmentType === ASSIGNMENT_TYPE_THU) {
        targetParentFolder = DriveApp.getFolderById(PARENT_FOLDER_THU_ID);
        emailSubjectBase = SUBJECT_TEMPLATE_THU;
        // Tính Quá hạn (dùng thời gian đã du di)
        if (currentTimeNum < TIME_OPEN_THU_NUM && currentTimeNum >= TIME_CLOSE_THU_NUM) {
            isOverdue = true;
        }
        // (*** MỚI V14.2 ***) Tính Nộp sớm (dùng thời gian GỐC)
        isEarly = checkIsEarly(now, TIME_CLOSE_THU_NUM, 2);
        
    } else if (assignmentType === ASSIGNMENT_TYPE_SUN) {
        targetParentFolder = DriveApp.getFolderById(PARENT_FOLDER_SUN_ID);
        emailSubjectBase = SUBJECT_TEMPLATE_SUN;
        // Tính Quá hạn
        if (currentTimeNum < TIME_OPEN_SUN_NUM || currentTimeNum >= TIME_CLOSE_SUN_NUM) {
            isOverdue = true;
        }
        // (*** MỚI V14.2 ***) Tính Nộp sớm
        isEarly = checkIsEarly(now, TIME_CLOSE_SUN_NUM, 2);

    } else { // (Bao gồm Khác và Mặc định)
        targetParentFolder = DriveApp.getFolderById(PARENT_FOLDER_OTH_ID);
        emailSubjectBase = SUBJECT_TEMPLATE_OTH;
        
        let deadlineNum; // (*** MỚI V14.2 ***)
        
        if (assignmentType === ASSIGNMENT_TYPE_OTH) { // Nếu là "Khác"
            // (*** CẬP NHẬT V24.7: Dùng mốc TIME_CLOSE_OTH_NUM_A mới ***)
            const isOnTime_A = (currentTimeNum >= TIME_OPEN_OTH_NUM_A && currentTimeNum < TIME_CLOSE_OTH_NUM_A);
            const isOnTime_B = (currentTimeNum >= TIME_OPEN_OTH_NUM_B && currentTimeNum < TIME_CLOSE_OTH_NUM_B);
            if (!(isOnTime_A || isOnTime_B)) {
                isOverdue = true;
            }
            // (*** MỚI V14.2 ***) Tìm hạn chót gần nhất cho Lớp Khác
            deadlineNum = (realTimeNum < TIME_OPEN_OTH_NUM_B) ? TIME_CLOSE_OTH_NUM_A : TIME_CLOSE_OTH_NUM_B;
            isEarly = checkIsEarly(now, deadlineNum, 1); // Yêu cầu 1 ngày

        } else { // Nếu là loại bài tập không xác định
            isOverdue = true;
            Logger.log(`Loại bài tập không hợp lệ ("${assignmentType}"). Đã chuyển vào thư mục "${targetParentFolder.getName()}" và đánh dấu Quá hạn.`);
            assignmentType = ASSIGNMENT_TYPE_OTH; // Ép về "Khác" để đánh dấu
            // (*** MỚI V14.2 ***) Tính hạn chót cho trường hợp mặc định
            deadlineNum = (realTimeNum < TIME_OPEN_OTH_NUM_B) ? TIME_CLOSE_OTH_NUM_A : TIME_CLOSE_OTH_NUM_B;
            isEarly = checkIsEarly(now, deadlineNum, 1);
        }
    }

    // === Phần 3: Xử lý file trên Drive (*** CẬP NHẬT V24.4 ***) ===
    
    // (V24.4) Đổi định dạng tên thư mục
    const studentFolderName = isOverdue ? `[Quá hạn] ${studentName}` : studentName;
    let studentFolder = findExistingStudentFolder(targetParentFolder, studentName);
    
    if (!studentFolder) {
        Logger.log(`Không tìm thấy thư mục thông minh cho "${studentName}". Đang tạo mới: "${studentFolderName}"`);
        studentFolder = targetParentFolder.createFolder(studentFolderName);
    } else {
        Logger.log(`Tìm thấy thư mục thông minh: "${studentFolder.getName()}". Sẽ gộp tệp vào đây.`);
        if (isOverdue && !studentFolder.getName().toLowerCase().includes("quá hạn")) {
            try {
                // (V24.4) Đổi định dạng tên thư mục
                const newOverdueName = `[Quá hạn] ${studentFolder.getName()}`;
                studentFolder.setName(newOverdueName);
                Logger.log(`Đã đổi tên thư mục thành: "${newOverdueName}"`);
            } catch (renameErr) {
                Logger.log(`Lỗi khi đổi tên thư mục thành quá hạn: ${renameErr.message}`);
            }
        }
    }

    // (V24.8+) Xử lý tệp: Không chuyển đổi DOCX, chỉ di chuyển về folder
    // Logic xử lý file trùng tên: so sánh kích cỡ, sau đó so sánh thời gian tạo
    const fileResponses = formResponse.getItemResponses().filter(item => item.getItem().getType() === FormApp.ItemType.FILE_UPLOAD);
    if (fileResponses.length > 0) {
      fileResponses.forEach(fileResponse => {
        const files = fileResponse.getResponse();
        files.forEach(fileId => {
          try {
            const file = DriveApp.getFileById(fileId);
            const fileName = file.getName();
            const fileSize = file.getSize();
            const fileTime = file.getLastUpdated().getTime();
            
            Logger.log(`[FILE HANDLING] Xử lý tệp: "${fileName}" (${fileSize} bytes, ${new Date(fileTime).toLocaleString('vi-VN')}) cho học sinh "${studentName}"`);
            
            // Kiểm tra xem file cùng tên đã có trong folder không
            const existingFilesIter = studentFolder.getFilesByName(fileName);
            if (existingFilesIter.hasNext()) {
              // File tên giống đã tồn tại
              const existingFile = existingFilesIter.next();
              const existingSize = existingFile.getSize();
              const existingTime = existingFile.getLastUpdated().getTime();
              
              Logger.log(`[FILE HANDLING] File tên "${fileName}" đã tồn tại. Existing: ${existingSize}B (${new Date(existingTime).toLocaleString('vi-VN')}), New: ${fileSize}B (${new Date(fileTime).toLocaleString('vi-VN')})`);
              
              // Nếu cùng kích cỡ → so sánh thời gian tạo để xác định file cũ
              if (fileSize === existingSize) {
                if (fileTime > existingTime) {
                  // File mới này MỚI HƠN → Xóa file CỦA
                  existingFile.setTrashed(true);
                  // Di chuyển file MỚI vào folder
                  file.moveTo(studentFolder);
                  Logger.log(`[FILE HANDLING] ✓ File mới (${new Date(fileTime).toLocaleString('vi-VN')}) MỚI hơn file cũ → XÓA file cũ, GIỮ file mới: "${fileName}".`);
                } else {
                  // File mới này CỦA HƠN (hoặc cùng thời gian) → Xóa file MỚI
                  file.setTrashed(true);
                  Logger.log(`[FILE HANDLING] ✓ File cũ (${new Date(existingTime).toLocaleString('vi-VN')}) CỦA hơn hoặc bằng file mới → XÓA file mới, GIỮ file cũ: "${fileName}".`);
                }
              } else {
                // Kích cỡ khác → giữ cả 2, di chuyển file mới vào folder
                file.moveTo(studentFolder);
                Logger.log(`[FILE HANDLING] ✓ Kích cỡ khác (${existingSize}B vs ${fileSize}B) → GIỮ cả 2 file. app.js sẽ sắp xếp theo thời gian: "${fileName}".`);
              }
            } else {
              // File không tồn tại trong folder → di chuyển file vào folder
              file.moveTo(studentFolder);
              Logger.log(`[FILE HANDLING] ✓ File MỚI (không tồn tại trước) → DI CHUYỂN vào folder: "${fileName}".`);
            }
          } catch (fileErr) {
            Logger.log(`[FILE HANDLING] LỖI khi xử lý tệp ID ${fileId}: ${fileErr.message}`);
          }
        });
      });
    } else {
      Logger.log(`[FILE HANDLING] Không có tệp nào được nộp cho học sinh "${studentName}".`);
    }

    // === Phần 4: (*** CẬP NHẬT V24 ***) Cập nhật Google Sheet (Logic 4 Giai đoạn) ===
    
    // Gọi Hàm 2 (V24) và truyền trạng thái "isEarly"
    findAndMarkCheckbox(studentName, assignmentType, "onFormSubmit", isEarly);


    // === Phần 5: Gửi Email thông báo (Giữ nguyên V14.1) ===
    if (RECIPIENT_EMAIL && RECIPIENT_EMAIL !== "your_email@example.com") {
      try {
        const overdueStatus = isOverdue ? " [QUÁ HẠN]" : "";
        const subject = `${emailSubjectBase} từ: ${studentName}${overdueStatus}`; 
        const body = `Bạn vừa nhận được bài nộp mới từ học sinh:\n\n`
                      + `Tên: ${studentName}\n`
                      + `Loại bài: ${assignmentType || 'Không xác định'}\n`
                      + `Trạng thái: ${isOverdue ? 'QUÁ HẠN' : 'Đúng hạn'}\n\n`
                      + `Thời gian nộp: ${now.toLocaleString('vi-VN')}\n`
                      + `Tệp đã được lưu vào thư mục: "${studentFolder.getName()}" (trong "${targetParentFolder.getName()}")`;

        MailApp.sendEmail(RECIPIENT_EMAIL, subject, body);
        Logger.log(`Đã gửi email thông báo tới ${RECIPIENT_EMAIL} cho ${studentName}.`);

      } catch (mailErr) {
        Logger.log(`Lỗi khi gửi email: ${mailErr.message}`);
      }
    } else {
      Logger.log("Chưa cấu hình RECIPIENT_EMAIL. Bỏ qua bước gửi mail.");
    }

  } catch (err) {
    Logger.log(`Lỗi nghiêm trọng trong onFormSubmit: ${err.message}`);
  }
}

// ------------------------------------------------------------------
// PHẦN CẦN THAY THẾ (V24.1)
// ------------------------------------------------------------------

/**
 * HÀM (HỖ TRỢ - CẬP NHẬT V24.1): Xóa SẠCH (File + Folder) trong thư mục cha.
 *
 * @param {GoogleAppsScript.Drive.Folder} parentFolder Thư mục cha cần dọn dẹp.
 */
function clearFolderContents(parentFolder) {
  if (!parentFolder) {
    Logger.log(`Lỗi (clearFolderContents): Thư mục cha không tồn tại hoặc ID sai.`);
    return;
  }
  
  const folderName = parentFolder.getName();
  Logger.log(`Đang dọn dẹp TOÀN BỘ nội dung trong: "${folderName}"...`);
  
  try {
    // 1. Xóa tất cả các TỆP TIN (Files) nằm trực tiếp trong thư mục cha
    const files = parentFolder.getFiles();
    let fileCount = 0;
    while (files.hasNext()) {
      const file = files.next();
      file.setTrashed(true);
      fileCount++;
    }

    // 2. Xóa tất cả các THƯ MỤC CON (Folders)
    const subfolders = parentFolder.getFolders();
    let folderCount = 0;
    while (subfolders.hasNext()) {
      const folder = subfolders.next();
      folder.setTrashed(true);
      folderCount++;
    }
    
    Logger.log(`Đã dọn dẹp xong "${folderName}": Xóa ${fileCount} tệp và ${folderCount} thư mục con.`);
    
  } catch (err) {
    Logger.log(`Lỗi khi dọn dẹp thư mục "${folderName}": ${err.message}`);
  }
}


/**
 * HÀM 2: (*** CẬP NHẬT V24 - LOGIC "KHỚP 2 TỪ CUỐI" ***)
 * (Giữ nguyên V24)
 */
function findAndMarkCheckbox(originalName, assignmentType, context, isEarly) {
  if (!originalName) return null;

  try {
    // === 1. CHỌN SHEET CẤU HÌNH (Giữ nguyên V14.3) ===
    let sheetNameConfig, sheetTabIdConfig, nameColumnLetter, checkboxColumnLetter;
    let expectedType; 

    if (assignmentType === ASSIGNMENT_TYPE_THU) {
        sheetNameConfig = SHEET_NAME_THU;
        sheetTabIdConfig = SHEET_TAB_ID_THU; 
        nameColumnLetter = NAME_COLUMN_THU; 
        checkboxColumnLetter = CHECKBOX_COLUMN_THU;
        expectedType = "THU";
    } else if (assignmentType === ASSIGNMENT_TYPE_SUN) {
        sheetNameConfig = SHEET_NAME_SUN;
        sheetTabIdConfig = SHEET_TAB_ID_SUN; 
        nameColumnLetter = NAME_COLUMN_SUN; 
        checkboxColumnLetter = CHECKBOX_COLUMN_SUN;
        expectedType = "SUN";
    } else {
        sheetNameConfig = SHEET_NAME_OTH;
        sheetTabIdConfig = SHEET_TAB_ID_OTH; 
        nameColumnLetter = NAME_COLUMN_OTH; 
        checkboxColumnLetter = CHECKBOX_COLUMN_OTH;
        expectedType = "OTH";
    }

    if (SHEET_ID === "YOUR_SINGLE_SHEET_ID_HERE") {
        Logger.log(`Chưa cấu hình SHEET_ID. Bỏ qua đánh dấu.`);
        return null;
    }

    let spreadSheet;
    try {
      spreadSheet = SpreadsheetApp.openById(SHEET_ID);
    } catch (openErr) {
      Logger.log(`LỖI NGHIÊM TRỌNG (findAndMarkCheckbox): Không thể mở Sheet ID. Lỗi: ${openErr.message}. Tên nộp: ${originalName}`);
      return null; 
    }
    
    const sheet = getSheetByTabId(spreadSheet, sheetTabIdConfig); 
    
    if (!sheet) {
      Logger.log(`Không tìm thấy Sheet Name "${sheetNameConfig}" (hoặc GID "${sheetTabIdConfig}").`);
      return null;
    }

    // (Giữ nguyên V14.3) Tự động tìm Cột Ưu điểm
    let advantageColumnLetter = null;
    if (isEarly && context === 'onFormSubmit') { 
      advantageColumnLetter = findAndCacheAdvantageColumn(sheet, sheetTabIdConfig);
    }

    // === 2. TẠO MAP DỮ LIỆU TỪ SHEET (*** CẬP NHẬT V24 ***) ===
    const nameColumnValues = sheet.getRange(`${nameColumnLetter}1:${nameColumnLetter}${sheet.getLastRow()}`).getValues();
    const checkboxValues = sheet.getRange(`${checkboxColumnLetter}1:${checkboxColumnLetter}${sheet.getLastRow()}`).getValues();
    
    const mapList = [];
    for (let i = 0; i < nameColumnValues.length; i++) {
        const nameInSheet = nameColumnValues[i][0];
        if (nameInSheet && typeof nameInSheet === 'string') {
            const isChecked = checkboxValues[i][0] === true;
            
            // (V24) Chuẩn hóa 1 lần
            const originalLC = nameInSheet.toLowerCase().trim();
            const normalizedName = normalizeString(nameInSheet); 
            const words = originalLC.split(/\s+/).filter(Boolean);
            const normalizedWords = normalizedName.split(/\s+/).filter(Boolean);

            // (*** MỚI V24: Lấy 2 từ cuối ***)
            const lastTwoWords = words.slice(-2).join(' '); // vd: "minh toàn" (có dấu)
            const normalizedLastTwoWords = normalizedWords.slice(-2).join(' '); // vd: "minh toan" (ko dấu)

            mapList.push({
                original: nameInSheet,
                originalLC: originalLC, // (V23)
                normalized: normalizedName, // (V23)
                
                // (*** MỚI V24 ***)
                lastTwoWords: lastTwoWords,
                normalizedLastTwoWords: normalizedLastTwoWords,
                
                row: i + 1,
                isChecked: isChecked,
                location: { 
                  type: expectedType,
                  row: i + 1,
                  isChecked: isChecked,
                  sheetTabId: sheetTabIdConfig,
                  sheetName: sheetNameConfig,
                  checkboxCol: checkboxColumnLetter
                }
            });
        }
    }
    
    const targetMapList = mapList; 
      
    if (targetMapList.length === 0) {
      Logger.log(`(Hàm 2) Không tìm thấy tên nào trong Sheet ${sheetNameConfig}.`);
      return null; 
    }

    // === 3. CHUẨN BỊ TÊN TỪ FORM/DRIVE (*** CẬP NHẬT V24 ***) ===
    // (V24) Chúng ta cần tên đầy đủ (chuỗi), không phải mảng từ
    const nameFromForm = originalName.toLowerCase().trim();
    const normalizedNameFromForm = normalizeString(originalName); 
    
    let bestMatch = null;
    let matchLevel = null;

    // === 4. CHẠY LOGIC GIAI ĐOẠN (*** CẬP NHẬT V24 ***) ===

    // -- GIAI ĐOẠN 1: Khớp tuyệt đối (có dấu) --
    bestMatch = targetMapList.find(item => item.originalLC === nameFromForm);
    if (bestMatch) matchLevel = "Phase 1 - Exact";

    // -- GIAI ĐOẠN 2: (MỚI V24) Khớp 2 Từ Cuối (có dấu) --
    // (Kiểm tra xem Tên Form/Drive CÓ CHỨA 2 từ cuối của Tên Sheet không)
    if (!bestMatch) {
      bestMatch = targetMapList.find(item => 
          item.lastTwoWords.length > 5 && // (Ngưỡng an toàn: "Minh Toàn" > 5)
          nameFromForm.includes(item.lastTwoWords)
      );
      if (bestMatch) matchLevel = "Phase 2 - LastTwo (Accent)";
    }

    // -- GIAI ĐOẠN 3: (MỚI V24) Khớp 2 Từ Cuối (KHÔNG dấu) --
    if (!bestMatch) {
      bestMatch = targetMapList.find(item => 
          item.normalizedLastTwoWords.length >= 5 && // (Ngưỡng an toàn)
          normalizedNameFromForm.includes(item.normalizedLastTwoWords)
      );
      if (bestMatch) matchLevel = "Phase 3 - LastTwo (Normalized)";
    }
    
    // --- NẾU GIAI ĐOẠN 1-3 THÀNH CÔNG: Đánh dấu và Thoát ---
    if (bestMatch) {
      const cellAddress = `${checkboxColumnLetter}${bestMatch.row}`;
      
      if (bestMatch.isChecked !== true) {
         sheet.getRange(cellAddress).setValue(true); // Đánh dấu TRUE
      }
      Logger.log(`(Hàm 2) Đã đánh dấu ${cellAddress} cho "${originalName}" (Khớp "${bestMatch.original}" - Cấp độ: ${matchLevel}).`);
      
      if (advantageColumnLetter) { 
        addEarlyComment(sheet, advantageColumnLetter, bestMatch.row);
      }
      return { match: bestMatch, level: matchLevel }; 
    }

    // -- GIAI ĐOẠN 4: SUY ĐOÁN TYPO (Levenshtein) --
    // (Giữ nguyên logic V23: so sánh tên đầy đủ)
    let typoTargetMapList = targetMapList;
    if (context === 'onFormSubmit') {
       typoTargetMapList = targetMapList.filter(item => !item.isChecked);
    }
    
    let typoCandidates = [];

    for (const item of typoTargetMapList) {
      const distance = levenshteinDistance(normalizedNameFromForm, item.normalized);
      if (distance <= TYPO_THRESHOLD && distance > 0) {
        typoCandidates.push({
            ...item,
            distance: distance
        });
      }
    }
    
    typoCandidates.sort((a, b) => a.distance - b.distance);

    // === 5. KẾT QUẢ VÀ GỬI EMAIL "ĐOÁN VÀ SỬA" (Giữ nguyên V23) ===
    if (typoCandidates.length > 0) {
      const bestGuess = typoCandidates[0];
      const otherCandidates = typoCandidates.slice(1); 
      
      const cellAddress = `${checkboxColumnLetter}${bestGuess.row}`;
      
      if (bestGuess.isChecked !== true) {
         sheet.getRange(cellAddress).setValue(true); // Đánh dấu TRUE
      }
      Logger.log(`(Hàm 2) GĐ 4: TỰ ĐỘNG ĐOÁN. Đã đánh dấu ${cellAddress} cho "${originalName}" (Khớp "${bestGuess.original}").`);

      if (advantageColumnLetter) { 
        addEarlyComment(sheet, advantageColumnLetter, bestGuess.row);
      }

      if (context.startsWith('onFormSubmit') || context.startsWith('reconcile')) {
         const scriptProperties = PropertiesService.getScriptProperties();
         const cacheKey = `reconcile_email_${sheetTabIdConfig}_${bestGuess.row}`;
         const alreadyEmailed = scriptProperties.getProperty(cacheKey);

         if (!alreadyEmailed) {
            sendCorrectionEmail(originalName, sheetNameConfig, sheetTabIdConfig, checkboxColumnLetter, bestGuess, otherCandidates);
            scriptProperties.setProperty(cacheKey, 'true', 21600 * 20); // 6 ngày
         } else {
            Logger.log(`(Hàm 2) Đã tìm thấy khớp Typo, nhưng đã gửi email cho ô ${cacheKey} trước đó. Bỏ qua gửi mail.`);
         }
      }
      
      return { match: bestGuess, level: "Phase 4 - Typo" }; 
    
    } else {
      Logger.log(`(Hàm 2) Không tìm thấy hàng nào khớp (kể cả Typo) với tên "${originalName}" (Sheet ${sheetNameConfig}).`);
      return null; 
    }

  } catch (err) {
    Logger.log(`Lỗi nghiêm trọng trong findAndMarkCheckbox: ${err.message}`);
    return null; 
  }
}


/**
 * HÀM 3: (*** CẬP NHẬT V24.9 - DỌN DẸP ĐỊNH KỲ CHÍNH XÁC ***)
 * Chạy dọn dẹp theo lịch cụ thể:
 * - T5 18:30: Đại số (THU) - xóa email, form responses, và dọn folder
 * - CN 17:00: Hình học (SUN) - xóa email, form responses, và dọn folder
 * 
 * YÊU CẦU: Trigger HOURLY (chạy hàng giờ)
 */
function runScheduledCleanupAndEnsureOpen() {
  try {
    const now = new Date();
    const day = now.getDay(); // 0:CN, 1:T2, ..., 4:T5, 5:T6, 6:T7
    const hour = now.getHours();
    const minute = now.getMinutes();
    
    Logger.log(`[CLEANUP] Kiểm tra lịch dọn dẹp: ${day === 4 ? 'THỨ 5' : day === 0 ? 'CHỦ NHẬT' : 'Ngày khác'} ${hour}:${minute.toString().padStart(2, '0')}`);

    // --- LỊCH ĐẠI SỐ: T5 18:30 ---
    if (day === 4 && hour === 18 && minute >= 30) {
      const scriptProperties = PropertiesService.getScriptProperties();
      const lastRunThu = scriptProperties.getProperty('LAST_CLEANUP_THU_TIME');
      const today = now.toLocaleDateString("vi-VN");
      
      // Kiểm tra xem hôm nay đã chạy chưa
      if (lastRunThu !== today) {
        Logger.log(">>> ĐẾN GIỜ DỌN DẸP: THỨ 5 18:30 (ĐẠI SỐ) <<<");
        
        try {
          // 1. Xóa email cũ
          cleanupOldEmails(SUBJECT_TEMPLATE_THU);
          
          // 2. Xóa form responses cũ (hơn 7 ngày)
          const form = FormApp.getActiveForm();
          cleanupFormResponsesByType(form, ASSIGNMENT_TYPE_THU, 7);
          
          // 3. Dọn dẹp folder
          const parentFolderThu = DriveApp.getFolderById(PARENT_FOLDER_THU_ID);
          clearFolderContents(parentFolderThu);
          
          // 4. Xóa cache email reconcile
          clearReconcileEmailCache(scriptProperties);
          
          // 5. Đánh dấu đã chạy hôm nay
          scriptProperties.setProperty('LAST_CLEANUP_THU_TIME', today);
          
          Logger.log("--- ✅ Hoàn tất dọn dẹp THỨ 5 (ĐẠI SỐ) ---");
        } catch (thuErr) {
          Logger.log(`LỖI khi dọn dẹp T5: ${thuErr.message}`);
        }
      } else {
        Logger.log(`[CLEANUP] T5 đã dọn dẹp hôm nay rồi. Sẽ chạy lại ngày mai.`);
      }
    }
    
    // --- LỊCH HÌNH HỌC: CN 17:00 ---
    else if (day === 0 && hour === 17 && minute >= 0) {
      const scriptProperties = PropertiesService.getScriptProperties();
      const lastRunSun = scriptProperties.getProperty('LAST_CLEANUP_SUN_TIME');
      const today = now.toLocaleDateString("vi-VN");
      
      // Kiểm tra xem hôm nay đã chạy chưa
      if (lastRunSun !== today) {
        Logger.log(">>> ĐẾN GIỜ DỌN DẸP: CHỦ NHẬT 17:00 (HÌNH HỌC) <<<");
        
        try {
          // 1. Xóa email cũ
          cleanupOldEmails(SUBJECT_TEMPLATE_SUN);
          
          // 2. Xóa form responses cũ (hơn 7 ngày)
          const form = FormApp.getActiveForm();
          cleanupFormResponsesByType(form, ASSIGNMENT_TYPE_SUN, 7);
          
          // 3. Dọn dẹp folder
          const parentFolderSun = DriveApp.getFolderById(PARENT_FOLDER_SUN_ID);
          clearFolderContents(parentFolderSun);
          
          // 4. Xóa cache email reconcile
          clearReconcileEmailCache(scriptProperties);
          
          // 5. Đánh dấu đã chạy hôm nay
          scriptProperties.setProperty('LAST_CLEANUP_SUN_TIME', today);
          
          Logger.log("--- ✅ Hoàn tất dọn dẹp CHỦ NHẬT (HÌNH HỌC) ---");
        } catch (sunErr) {
          Logger.log(`LỖI khi dọn dẹp CN: ${sunErr.message}`);
        }
      } else {
        Logger.log(`[CLEANUP] CN đã dọn dẹp hôm nay rồi. Sẽ chạy lại tuần sau.`);
      }
    }

  } catch (err) {
    Logger.log(`LỖI NGHIÊM TRỌNG trong runScheduledCleanupAndEnsureOpen: ${err.message}`);
  }
}


/**
 * HÀM (HỖ TRỢ): Dọn dẹp email cũ.
 * (Giữ nguyên V13/V24)
 */
function cleanupOldEmails(subjectTemplate) {
  try {
    if (!subjectTemplate) {
        Logger.log("cleanupOldEmails: Không có mẫu tiêu đề (subjectTemplate), không thể xóa email.");
        return;
    }
    const searchQuery = `subject:"${subjectTemplate}" in:inbox is:read`; 
    const threads = GmailApp.search(searchQuery);
    if (threads.length > 0) {
      GmailApp.moveThreadsToTrash(threads);
      Logger.log(`Đã xóa ${threads.length} email thông báo cũ.`);
    } else {
      Logger.log("Không tìm thấy email thông báo cũ nào.");
    }
  } catch (gmailErr) {
    Logger.log(`Lỗi khi dọn dẹp email cũ: ${gmailErr.message}`);
  }
}

/**
 * HÀM (HỖ TRỢ): Dọn dẹp câu trả lời form cũ.
 * (Giữ nguyên V13/V24)
 */
function cleanupOldFormResponses(form, assignmentTypeToDelete) {
    Logger.log(`Bắt đầu xóa câu trả lời Form cho: "${assignmentTypeToDelete}"`);
    let deleteCount = 0;
    try {
      const responses = form.getResponses();
      let assignmentQuestionItemId = null;
      const items = form.getItems();
      for (let i = 0; i < items.length; i++) {
        if (items[i].getTitle() === ASSIGNMENT_TYPE_QUESTION_TITLE) {
          assignmentQuestionItemId = items[i].getId();
          break;
        }
      }

      if (assignmentQuestionItemId === null) {
        Logger.log(`Không tìm thấy ID câu hỏi cho: "${ASSIGNMENT_TYPE_QUESTION_TITLE}". Không thể xóa câu trả lời.`);
        return;
      }

      for (let i = 0; i < responses.length; i++) {
        const response = responses[i];
        let itemResponse;
        try {
           itemResponse = response.getResponseForItem(form.getItemById(assignmentQuestionItemId));
        } catch (e) {
           continue; 
        }

        if (itemResponse && itemResponse.getResponse() === assignmentTypeToDelete) {
          form.deleteResponse(response.getId());
          deleteCount++;
        }
      }
      Logger.log(`ĐÃ XÓA ${deleteCount} câu trả lời khớp với "${assignmentTypeToDelete}".`);
    } catch (err) {
      Logger.log(`Lỗi khi xóa câu trả lời có chọn lọc: ${err.message}`);
    }
}

/**
 * HÀM (HỖ TRỢ MỚI V24.8+): Dọn dẹp TOÀN BỘ câu trả lời Form cũ theo lịch.
 * Gọi từ onFormSubmit trigger (có Form context).
 */
function cleanupAllOldFormResponses(form) {
  try {
    Logger.log(">>> (V24.8+) Bắt đầu dọn dẹp TOÀN BỘ câu trả lời Form cũ <<<");
    
    const responses = form.getResponses();
    if (!responses || responses.length === 0) {
      Logger.log("Không có câu trả lời để dọn dẹp.");
      return;
    }

    let deleteCount = 0;
    const now = new Date();
    const retentionDays = 7; // Giữ lại 7 ngày gần nhất
    const cutoffTime = now.getTime() - (retentionDays * 24 * 60 * 60 * 1000);

    for (let i = 0; i < responses.length; i++) {
      const response = responses[i];
      const timestamp = response.getTimestamp();
      
      if (timestamp && timestamp.getTime() < cutoffTime) {
        try {
          form.deleteResponse(response.getId());
          deleteCount++;
        } catch (deleteErr) {
          Logger.log(`Lỗi khi xóa response: ${deleteErr.message}`);
        }
      }
    }

    Logger.log(`--- Hoàn tất dọn dẹp. ĐÃ XÓA ${deleteCount} câu trả lời cũ hơn ${retentionDays} ngày ---`);

  } catch (err) {
    Logger.log(`Lỗi nghiêm trọng trong cleanupAllOldFormResponses: ${err.message}`);
  }
}

/**
 * HÀM (HỖ TRỢ MỚI V24.9): Xóa form responses của một loại bài tập cũ hơn N ngày.
 * Dùng cho dọn dẹp định kỳ (chạy từ hourly trigger với Form context).
 */
function cleanupFormResponsesByType(form, assignmentType, retentionDays) {
  try {
    Logger.log(`[CLEANUP] Bắt đầu xóa form responses cho "${assignmentType}" cũ hơn ${retentionDays} ngày`);
    
    const responses = form.getResponses();
    if (!responses || responses.length === 0) {
      Logger.log(`[CLEANUP] Không có response để xóa cho "${assignmentType}".`);
      return;
    }

    let deleteCount = 0;
    const now = new Date();
    const cutoffTime = now.getTime() - (retentionDays * 24 * 60 * 60 * 1000);

    // Tìm câu hỏi Assignment Type
    let assignmentQuestionItemId = null;
    const items = form.getItems();
    for (let i = 0; i < items.length; i++) {
      if (items[i].getTitle() === ASSIGNMENT_TYPE_QUESTION_TITLE) {
        assignmentQuestionItemId = items[i].getId();
        break;
      }
    }

    if (!assignmentQuestionItemId) {
      Logger.log(`[CLEANUP] Không tìm thấy câu hỏi "${ASSIGNMENT_TYPE_QUESTION_TITLE}".`);
      return;
    }

    // Lặp qua các responses
    for (let i = 0; i < responses.length; i++) {
      const response = responses[i];
      const timestamp = response.getTimestamp();

      // Kiểm tra timestamp
      if (!timestamp || timestamp.getTime() >= cutoffTime) {
        continue; // Bỏ qua responses mới hơn
      }

      // Kiểm tra assignment type
      let itemResponse;
      try {
        itemResponse = response.getResponseForItem(form.getItemById(assignmentQuestionItemId));
      } catch (e) {
        continue;
      }

      if (itemResponse && itemResponse.getResponse() === assignmentType) {
        try {
          form.deleteResponse(response.getId());
          deleteCount++;
        } catch (deleteErr) {
          Logger.log(`[CLEANUP] Lỗi xóa response: ${deleteErr.message}`);
        }
      }
    }

    Logger.log(`[CLEANUP] ✅ Đã xóa ${deleteCount} responses của "${assignmentType}" cũ hơn ${retentionDays} ngày.`);

  } catch (err) {
    Logger.log(`[CLEANUP] Lỗi trong cleanupFormResponsesByType: ${err.message}`);
  }
}

// ------------------------------------------------------------------
// KẾT THÚC PHẦN THAY THẾ
// ------------------------------------------------------------------


/**
 * HÀM 4: DỌN DẸP ĐỊNH KỲ (DOCX)
 * (DEPRECATED - V24.8+) - Hàm này không còn dùng vì DOCX conversion đã bị bỏ
 */
function periodicCleanup() {
  Logger.log(`[DEPRECATED] periodicCleanup() không còn hoạt động trong V24.8+. DOCX conversion đã bị bỏ.`);
  return;
}

/**
 * HÀM (HỖ TRỢ): Quét một thư mục cha, tìm thư mục con và chuyển đổi tệp docx.
 * (DEPRECATED - V24.8+) - Hàm này không còn hoạt động vì bỏ DOCX conversion
 * Giữ lại để backward compatibility nhưng sẽ không làm gì.
 */
function scanAndConvertFolder(parentFolder) {
  if (!parentFolder) {
    Logger.log(`Không tìm thấy một thư mục cha, bỏ qua quét DOCX.`);
    return 0;
  }

  Logger.log(`[DEPRECATED] scanAndConvertFolder() không còn hoạt động trong V24.8+. DOCX conversion đã bị bỏ.`);
  return 0;
}


// ==================================================================
// CÁC HÀM HỖ TRỢ (Tiện ích)
// ==================================================================

/**
 * (DEPRECATED - V24.8+) Hàm này không còn dùng nữa.
 * Lý do: DOCX → PDF conversion bị lỗi, gây mất dữ liệu học sinh.
 * Thay vào đó: app.js đã có hàm xử lý file upload riêng biệt.
 * File DOCX/Word sẽ được di chuyển vào folder nhưng app.js sẽ xử lý.
 * 
 * Hàm này giữ lại để backward compatibility nhưng không được gọi.
 */
function convertFileToPdf(file, targetFolder) {
  // [V24.8+] Hàm này đã deprecated
  // KHÔNG chuyển đổi DOCX nữa vì gây mất file khi conversion lỗi
  Logger.log(`[DEPRECATED] convertFileToPdf() không được dùng trong V24.8+`);
  return;
}


/**
 * (Giữ nguyên V13) Lấy câu trả lời từ một FormResponse bằng Tiêu đề câu hỏi.
 */
function getResponseByTitle(formResponse, title) {
  const itemResponses = formResponse.getItemResponses();
  for (let i = 0; i < itemResponses.length; i++) {
    if (itemResponses[i].getItem().getTitle() === title) {
      return itemResponses[i].getResponse();
    }
  }
  return null;
}

/**
 * (Giữ nguyên V13) Lấy một thư mục. Nếu chưa có, tạo mới.
 */
function getOrCreateFolder(root, folderName) {
  const folders = root.getFoldersByName(folderName);
  if (folders.hasNext()) {
    return folders.next();
  } else {
    return root.createFolder(folderName);
  }
}

/**
 * (Giğữ nguyên V13) Lấy một thư mục chỉ bằng tên (không tạo mới).
 */
function getFolderByName(root, folderName) {
  const folders = root.getFoldersByName(folderName);
  if (folders.hasNext()) {
    return folders.next();
  }
  return null;
}

/**
 * (HELPER V24.10): Kiểm tra xem file có tên đã tồn tại trong folder
 */
function doesFileExistInFolder(parentFolder, fileName) {
  const files = parentFolder.getFilesByName(fileName);
  return files.hasNext();
}

/**
 * (Giữ nguyên V23: Dùng logic "Smart Match" (A.every || B.every))
 * Tìm kiếm thông minh một thư mục con dựa trên tên học sinh.
 * (*** CẬP NHẬT V24.9: Cải thiện để đảm bảo tìm thấy folder ngay cả sau cleanup ***)
 */
function findExistingStudentFolder(parentFolder, studentName) {
  try {
    const studentNameNormalized = normalizeString(studentName);
    const studentNameWords = studentNameNormalized.split(/\s+/).filter(Boolean);
    const allSubfolders = parentFolder.getFolders();
    let foundFolders = [];

    Logger.log(`[FOLDER SEARCH] Tìm kiếm folder cho học sinh: "${studentName}" (normalized: "${studentNameNormalized}")`);

    while (allSubfolders.hasNext()) {
      const folder = allSubfolders.next();
      const folderName = folder.getName();
      
      const folderNameNormalized = normalizeString(folderName);
      const folderNameWords = folderNameNormalized.split(/\s+/).filter(Boolean);

      if (folderNameWords.length === 0 || studentNameWords.length === 0) continue;

      const studentWordsInFolder = studentNameWords.every(word => folderNameWords.includes(word));
      const folderWordsInStudent = folderNameWords.every(word => studentNameWords.includes(word));

      if (studentWordsInFolder || folderWordsInStudent) {
        Logger.log(`[FOLDER SEARCH] ✓ Tìm thấy folder khớp: "${folderName}" (normalized: "${folderNameNormalized}")`);
        foundFolders.push(folder);
      }
    }

    if (foundFolders.length === 1) {
      Logger.log(`[FOLDER SEARCH] ✓ Xác định 1 folder khớp duy nhất: "${foundFolders[0].getName()}"`);
      return foundFolders[0];
    } else if (foundFolders.length > 1) {
       Logger.log(`[FOLDER SEARCH] ⚠ Tìm thấy ${foundFolders.length} thư mục khớp với "${studentName}". Sẽ tạo thư mục mới để tránh nhầm lẫn.`);
       Logger.log(`[FOLDER SEARCH] Các folder tìm thấy: ${foundFolders.map(f => f.getName()).join(", ")}`);
       return null;
    } else {
       Logger.log(`[FOLDER SEARCH] ✗ Không tìm thấy folder nào khớp với "${studentName}". Sẽ tạo thư mục mới.`);
       return null;
    }

  } catch (err) {
       Logger.log(`[FOLDER SEARCH] LỖI: Lỗi khi tìm kiếm thư mục thông minh: ${err.message}`);
       return null;
  }
}


/**
 * (Giữ nguyên V13)
 */
function openForm() {
  const form = FormApp.getActiveForm();
  form.setAcceptingResponses(true);
  Logger.log("Đã MỞ biểu mẫu (chạy thủ công).");
}
/**
 * (Giữ nguyên V13)
 */
function closeForm() {
  const form = FormApp.getActiveForm();
  form.setAcceptingResponses(false);
  Logger.log("Đã ĐÓNG biểu mẫu (chạy thủ công).");
}

// ==================================================================
// HÀM 5: (*** CẬP NHẬT V24 - GỌI HÀM 2 (V24) ***) 
// (Giữ nguyên logic V21/V23 - Chỉ gọi Hàm 2)
// ==================================================================

/**
 * HÀM (HỖ TRỢ V21): Quét Drive để xây dựng "Bản đồ Nguồn Sự Thật".
 * (Giữ nguyên V23)
 */
function buildDriveStudentMap_V21() {
  Logger.log("(V21) Bắt đầu quét 3 thư mục Drive để xây dựng bản đồ (List)...");
  const driveList = []; 
  const driveMap = {}; 

  // Hàm con để quét một thư mục cha
  const scanParentFolder = (folderId, assignmentType) => {
    try {
      const parentFolder = DriveApp.getFolderById(folderId);
      const subfolders = parentFolder.getFolders();
      
      while (subfolders.hasNext()) {
        const folder = subfolders.next();
        const originalName = folder.getName();
        
        if (originalName.startsWith("[") && originalName.endsWith("]")) {
           Logger.log(`(V21) Bỏ qua thư mục lưu trữ: ${originalName}`);
           continue;
        }

        const normalizedName = normalizeString(originalName); 
        
        if (normalizedName) {
          if (!driveMap[normalizedName]) {
            driveMap[normalizedName] = {
              original: originalName, 
              normalized: normalizedName,
              types: [] 
            };
          }
          if (!driveMap[normalizedName].types.includes(assignmentType)) {
             driveMap[normalizedName].types.push(assignmentType);
          }
        }
      }
      Logger.log(`(V21) Quét xong ${parentFolder.getName()}, gán loại: ${assignmentType}`);
    } catch (e) {
      Logger.log(`(V21) Lỗi khi quét Folder ID ${folderId}: ${e.message}`);
    }
  };

  scanParentFolder(PARENT_FOLDER_THU_ID, "THU");
  scanParentFolder(PARENT_FOLDER_SUN_ID, "SUN");
  scanParentFolder(PARENT_FOLDER_OTH_ID, "OTH");

  for (const key in driveMap) {
    driveList.push(driveMap[key]);
  }

  Logger.log(`(V21) Xây dựng bản đồ (List) hoàn tất. Tìm thấy ${driveList.length} học sinh.`);
  return driveList;
}

/**
 * HÀM (HỖ TRỢ V21): Chuyển đổi Key ("THU") sang Tên Form đầy đủ
 */
function convertDriveTypeToAssignmentType(typeKey) {
  if (typeKey === "THU") return ASSIGNMENT_TYPE_THU;
  if (typeKey === "SUN") return ASSIGNMENT_TYPE_SUN;
  if (typeKey === "OTH") return ASSIGNMENT_TYPE_OTH;
  return ASSIGNMENT_TYPE_OTH;
}


/**
 * HÀM 5: (*** CẬP NHẬT V21/V23 ***) 
 * ĐỐI SOÁT ĐỊNH KỲ (Đơn giản hóa - Chỉ Check, Không Hủy Check)
 * (*** CẬP NHẬT V24: Cập nhật tên hàm (context) ***)
 */
function reconcileCheckboxes() {
  Logger.log("--- (V24) Bắt đầu Đối soát Định kỳ (LOGIC LAST-TWO, CHỈ CHECK) ---");
  
  try {
    const driveList = buildDriveStudentMap_V21();

    if (driveList.length === 0) {
      Logger.log("(V24) Không tìm thấy thư mục học sinh nào trên Drive. Kết thúc đối soát.");
      return;
    }

    Logger.log(`(V24) Bắt đầu Giai đoạn 1 (Khớp Drive -> Sheet) cho ${driveList.length} thư mục...`);

    for (const driveItem of driveList) {
      const driveName = driveItem.original;
      const driveTypes = driveItem.types;

      if (!driveTypes || driveTypes.length === 0) continue;

      for (const typeKey of driveTypes) {
        const assignmentType = convertDriveTypeToAssignmentType(typeKey); 
        
        Logger.log(`(V24) Đang đối soát: Tên Drive "${driveName}" cho Loại "${assignmentType}"`);
        
        // Gọi "Công cụ So khớp" (Hàm 2 - V24)
        findAndMarkCheckbox(
          driveName, 
          assignmentType, 
          "reconcile-v24", // (Context mới V24)
          false 
        );
      }
    }

    Logger.log("--- (V24) Hoàn tất Đối soát (LOGIC LAST-TWO, CHỈ CHECK). ---");

  } catch (err) {
    Logger.log(`(V24) LỖI NGHIÊM TRỌNG trong reconcileCheckboxes: ${err.message}`);
  }
}


// ==================================================================
// CÁC HÀM HỖ TRỢ MỚI (V13 / V14 / V14.3 / V20 / V21 / V23 / V24)
// ==================================================================

/**
 * HÀM (HỖ TRỢ MỚI V14): Gửi Email Sửa lỗi (khi tự động đoán)
 * (Giữ nguyên V23)
 */
function sendCorrectionEmail(suspectName, sheetName, sheetTabId, checkboxCol, bestGuess, otherCandidates) {
  if (!RECIPIENT_EMAIL) return;

  try {
    const webAppUrl = ScriptApp.getService().getUrl();
    if (!webAppUrl) {
      Logger.log("LỖI: Script CHƯA ĐƯỢC TRIỂN KHAI DƯỚI DẠNG WEB APP. Không thể gửi email tương tác.");
      return;
    }
    
    let buttonsHtml = "";
    otherCandidates.forEach(candidate => {
      
      const location = candidate.location; 
      if (!location) return; 

      const bestGuessLocation = bestGuess.location;
      if (!bestGuessLocation) {
         Logger.log(`LỖI (sendCorrectionEmail): bestGuess ${bestGuess.original} không có 'location'.`);
         return; 
      }
      
      const url = new URL(webAppUrl);
      url.searchParams.append("action", "correct");
      url.searchParams.append("sheetTabId", location.sheetTabId); 
      url.searchParams.append("formName", suspectName);
      url.searchParams.append("oldRow", bestGuessLocation.row);
      url.searchParams.append("oldCol", bestGuessLocation.checkboxCol);
      url.searchParams.append("newRow", location.row);
      url.searchParams.append("newCol", location.checkboxCol);
      
      buttonsHtml += `
        <a href="${url.href}" target="_blank" style="
          display: inline-block; padding: 10px 15px; margin: 5px 5px 5px 0;
          background-color: #ffc107; color: #212529; text-decoration: none;
          border-radius: 5px; font-weight: bold; border: 1px solid #e0a800;
        ">
          Chọn: ${candidate.original}
        </a>
      `;
    });

    const subject = `[CẢNH BÁO] Đã tự động đoán tên nộp bài: "${suspectName}"`;
    const bodyHtml = `
      <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6;">
          <h2>Hệ thống đã tự động suy đoán</h2>
          <p>Bài nộp từ tên: <strong>"${suspectName}"</strong> (từ Form hoặc Drive) đã được tự động khớp và đánh dấu là:</p>
          <p style="
            font-size: 1.2em; font-weight: bold; color: #28a745; padding: 10px;
            background-color: #f0f9f2; border-left: 5px solid #28a745;
          ">
            ${bestGuess.original} (Sheet: ${sheetName})
          </p>
          <p>Nếu suy đoán này là <strong>SAI</strong>, vui lòng chọn lại tên chính xác bên dưới. (Nếu không làm gì, suy đoán sẽ được giữ nguyên).</p>
          <div style="padding: 10px 0;">
            ${buttonsHtml}
          </div>
          <p style="font-size: 0.9em; color: #777;">
            (Nếu tất cả đều sai, vui lòng bỏ qua email này và kiểm tra thủ công trên Google Sheet.)
          </p>
        </body>
      </html>
    `;

    MailApp.sendEmail({
      to: RECIPIENT_EMAIL,
      subject: subject,
      htmlBody: bodyHtml
    });
    
    Logger.log(`Đã gửi email CẢNH BÁO & SỬA LỖI (Đoán ${bestGuess.original}) cho "${suspectName}".`);

  } catch (e) {
    Logger.log(`Lỗi khi gửi email sửa lỗi: ${e.message}`);
  }
}


/**
 * HÀM (HỖ TRỢ MỚI V23): Chuẩn hóa chuỗi (Lowercase, Bỏ dấu, Xóa TẤT CẢ ngoặc, Xóa Tiền tố)
 * (Giữ nguyên V23)
 */
function normalizeString(str) {
  if (!str || typeof str !== 'string') {
    return "";
  }
  
  const prefixRegex = new RegExp(`^(${PREFIX_KEYWORDS_TO_REMOVE.join("|")})\\s+`, 'g');

  let s = str.toLowerCase(); // (V23) Luôn lowercase ĐẦU TIÊN

  return s.trim()
          .replace(prefixRegex, "") 
          .replace(/[\(\[\{].*?[\)\]\}]/g, "") 
          .replace(/[-_,\/\\|]/g, ' ')
          .normalize('NFD') 
          .replace(/[\u0300-\u036f]/g, '') 
          .replace(/đ/g, 'd') 
          .replace(/\s+/g, ' ') 
          .trim(); 
}

/**
 * HÀM (HỖ TRỢ MỚI V11): Tính khoảng cách Levenshtein (Đo lường lỗi Typo)
 * (Giữ nguyên V13)
 */
function levenshteinDistance(s1, s2) {
  s1 = s1 || "";
  s2 = s2 || "";
  const m = s1.length;
  const n = s2.length;
  let dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));

  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      let cost = (s1[i - 1] === s2[j - 1]) ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,      // Deletion (Xóa)
        dp[i][j - 1] + 1,      // Insertion (Chèn)
        dp[i - 1][j - 1] + cost // Substitution (Thay thế)
      );
    }
  }
  return dp[m][n];
}

/**
 * HÀM (HỖ TRỢ MỚI V14): Tìm một trang tính (tab) bằng GID của nó.
 */
function getSheetByTabId(spreadsheet, id) {
  if (!spreadsheet || id == null) return null;
  
  const sheets = spreadsheet.getSheets();
  for (let i = 0; i < sheets.length; i++) {
    if (sheets[i].getSheetId() == id) { 
      return sheets[i];
    }
  }
  return null; // Không tìm thấy
}

/**
 * HÀM (HỖ TRỢ MỚI V14.2): Thêm lời khen nộp sớm vào cột
 */
function addEarlyComment(sheet, col, row) {
  try {
    if (!col || !row) {
       Logger.log("Lỗi (addEarlyComment): Thiếu cột hoặc hàng.");
       return;
    }
    const cellAddress = `${col}${row}`;
    const cell = sheet.getRange(cellAddress);
    const currentComment = cell.getValue().toString();
    
    if (currentComment.includes(EARLY_SUBMISSION_COMMENT)) {
      Logger.log(`Nhận xét nộp sớm đã tồn tại tại ô ${cellAddress}.`);
      return;
    }
    
    const newComment = currentComment ? (currentComment + "\n" + EARLY_SUBMISSION_COMMENT) : EARLY_SUBMISSION_COMMENT;
    cell.setValue(newComment);
    Logger.log(`Đã thêm nhận xét nộp sớm tại ô ${cellAddress}.`);
  
  } catch (err) {
    Logger.log(`Lỗi khi thêm nhận xét nộp sớm tại ${col}${row}: ${err.message}`);
  }
}

/**
 * HÀM (HỖ TRỢ MỚI V14.2): Kiểm tra xem có nộp sớm không
 */
function checkIsEarly(submissionDate, deadlineNum, daysEarlyRequired) {
  try {
    const deadlineDay = Math.floor(deadlineNum / 10000); // 3 (Wed)
    const deadlineHour = Math.floor((deadlineNum % 10000) / 100); // 12
    const deadlineMinute = deadlineNum % 100; // 0

    let deadlineDate = new Date(submissionDate.getTime());
    
    const dayOffset = (deadlineDay - submissionDate.getDay() + 7) % 7;
    deadlineDate.setDate(deadlineDate.getDate() + dayOffset);
    deadlineDate.setHours(deadlineHour, deadlineMinute, 0, 0);

    if (deadlineDate.getTime() < submissionDate.getTime()) {
      deadlineDate.setDate(deadlineDate.getDate() + 7); 
    }
    
    const msInDay = 24 * 60 * 60 * 1000;
    const requiredMsEarly = daysEarlyRequired * msInDay;
    
    const timeDifference = deadlineDate.getTime() - submissionDate.getTime();
    
    if (timeDifference >= requiredMsEarly) {
      Logger.log(`Phát hiện NỘP SỚM! (Sớm ${Math.floor(timeDifference / msInDay)} ngày so với hạn).`);
      return true;
    }
    return false;

  } catch (e) {
    Logger.log(`Lỗi khi kiểm tra nộp sớm: ${e.message}`);
    return false;
  }
}

/**
 * HÀM (HỖ TRỢ MỚI V14.3): Tìm và cache cột Ưu điểm.
 */
function findAndCacheAdvantageColumn(sheet, sheetTabId) {
  const cache = PropertiesService.getScriptProperties();
  const cacheKey = `ADV_COL_GID_${sheetTabId}`; 

  const cachedCol = cache.getProperty(cacheKey);
  if (cachedCol) {
    Logger.log(`(Cache) Đã tìm thấy Cột Ưu điểm: ${cachedCol}`);
    return (cachedCol === "NONE") ? null : cachedCol;
  }

  Logger.log(`(Cache) Không tìm thấy Cột Ưu điểm, đang quét hàng 1 của Sheet GID ${sheetTabId}...`);
  try {
    const headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    let foundColLetter = null;

    for (let i = 0; i < headerRow.length; i++) {
      const headerText = normalizeString(headerRow[i]);
      if (!headerText) continue;

      const foundKeyword = ADVANTAGE_KEYWORDS.some(keyword => headerText.includes(keyword));
      
      if (foundKeyword) {
        foundColLetter = colIndexToLetter(i + 1); 
        Logger.log(`(Cache) Đã tìm thấy Cột Ưu điểm tại: ${foundColLetter} (Tiêu đề: "${headerRow[i]}")`);
        break; 
      }
    }

    if (foundColLetter) {
      cache.setProperty(cacheKey, foundColLetter);
      return foundColLetter;
    } else {
      Logger.log(`(Cache) Không tìm thấy cột nào khớp từ khóa [${ADVANTAGE_KEYWORDS.join(", ")}]`);
      cache.setProperty(cacheKey, "NONE"); 
      return null;
    }

  } catch (err) {
    Logger.log(`Lỗi nghiêm trọng khi tìm Cột Ưu điểm: ${err.message}`);
    return null;
  }
}

/**
 * HÀM (HỖ TRỢ MỚI V14.3): Chuyển đổi số thứ tự cột sang chữ cái (1 -> A, 2 -> B)
 */
function colIndexToLetter(colIndex) {
  let temp, letter = '';
  while (colIndex > 0) {
    temp = (colIndex - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    colIndex = (colIndex - temp - 1) / 26;
  }
  return letter;
}

/**
 * HÀM (HỖ TRỢ MỚI V20): Xóa cache email reconcile khi dọn dẹp hàng tuần
 */
function clearReconcileEmailCache(scriptProperties) {
  try {
    const allKeys = scriptProperties.getKeys();
    let deleteCount = 0;
    allKeys.forEach(key => {
      if (key.startsWith("reconcile_email_")) {
        scriptProperties.deleteProperty(key);
        deleteCount++;
      }
    });
    Logger.log(`(V20) Đã xóa ${deleteCount} cờ cache email reconcile.`);
  } catch (e) {
    Logger.log(`(V20) Lỗi khi xóa cache email: ${e.message}`);
  }
}